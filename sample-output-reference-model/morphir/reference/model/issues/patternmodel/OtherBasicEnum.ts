// Generated by morphir-elm

import * as codecs from "./../../../../../morphir/internal/Codecs";

export namespace Morphir_Reference_Model_Issues_PatternModel_OtherBasicEnum {
  export type OtherBasicEnum = A | B | C | D | E | F | None;

  export function decodeOtherBasicEnum(input: any): OtherBasicEnum {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "A":
        return decodeA(input);
      case "B":
        return decodeB(input);
      case "C":
        return decodeC(input);
      case "D":
        return decodeD(input);
      case "E":
        return decodeE(input);
      case "F":
        return decodeF(input);
      case "None":
        return decodeNone(input);
    }
    codecs.raiseDecodeErrorFromCustomType("OtherBasicEnum", kind);
  }

  export function encodeOtherBasicEnum(value: OtherBasicEnum): any {
    switch (value.kind) {
      case "A":
        return encodeA(value);
      case "B":
        return encodeB(value);
      case "C":
        return encodeC(value);
      case "D":
        return encodeD(value);
      case "E":
        return encodeE(value);
      case "F":
        return encodeF(value);
      case "None":
        return encodeNone(value);
    }
  }

  export class A {
    kind: "A" = "A";

    constructor() {}
  }

  export function decodeA(input: any): A {
    codecs.preprocessCustomTypeVariant("A", 0, input);
    return new A();
  }

  export function encodeA(value: A): any {
    return value.kind;
  }

  export class B {
    kind: "B" = "B";

    constructor() {}
  }

  export function decodeB(input: any): B {
    codecs.preprocessCustomTypeVariant("B", 0, input);
    return new B();
  }

  export function encodeB(value: B): any {
    return value.kind;
  }

  export class C {
    kind: "C" = "C";

    constructor() {}
  }

  export function decodeC(input: any): C {
    codecs.preprocessCustomTypeVariant("C", 0, input);
    return new C();
  }

  export function encodeC(value: C): any {
    return value.kind;
  }

  export class D {
    kind: "D" = "D";

    constructor() {}
  }

  export function decodeD(input: any): D {
    codecs.preprocessCustomTypeVariant("D", 0, input);
    return new D();
  }

  export function encodeD(value: D): any {
    return value.kind;
  }

  export class E {
    kind: "E" = "E";

    constructor() {}
  }

  export function decodeE(input: any): E {
    codecs.preprocessCustomTypeVariant("E", 0, input);
    return new E();
  }

  export function encodeE(value: E): any {
    return value.kind;
  }

  export class F {
    kind: "F" = "F";

    constructor() {}
  }

  export function decodeF(input: any): F {
    codecs.preprocessCustomTypeVariant("F", 0, input);
    return new F();
  }

  export function encodeF(value: F): any {
    return value.kind;
  }

  export class None {
    kind: "None" = "None";

    constructor() {}
  }

  export function decodeNone(input: any): None {
    codecs.preprocessCustomTypeVariant("None", 0, input);
    return new None();
  }

  export function encodeNone(value: None): any {
    return value.kind;
  }
}
