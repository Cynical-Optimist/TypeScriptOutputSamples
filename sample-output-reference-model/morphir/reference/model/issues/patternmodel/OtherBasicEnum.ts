// Generated by morphir-elm

import * as codecs from "./../../../../../morphir/internal/Codecs"

export namespace Morphir_Reference_Model_Issues_PatternModel_OtherBasicEnum {
  
  export type OtherBasicEnum = A | B | C | D | E | F | None
  
  export function decodeOtherBasicEnum(varDecoders, input) {
  let decoderMap = new Map();
  decoderMap.set("A", decodeA.bind(varDecoders));
  decoderMap.set("B", decodeB.bind(varDecoders));
  decoderMap.set("C", decodeC.bind(varDecoders));
  decoderMap.set("D", decodeD.bind(varDecoders));
  decoderMap.set("E", decodeE.bind(varDecoders));
  decoderMap.set("F", decodeF.bind(varDecoders));
  decoderMap.set("None", decodeNone.bind(varDecoders));
  codecs.decodeCustomType(decoderMap, input);
  }
  
  
  
  export interface A {
    kind: "A";
  }
  
  export function decodeA(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("A", [], [], input);
  }
  
  export interface B {
    kind: "B";
  }
  
  export function decodeB(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("B", [], [], input);
  }
  
  export interface C {
    kind: "C";
  }
  
  export function decodeC(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("C", [], [], input);
  }
  
  export interface D {
    kind: "D";
  }
  
  export function decodeD(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("D", [], [], input);
  }
  
  export interface E {
    kind: "E";
  }
  
  export function decodeE(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("E", [], [], input);
  }
  
  export interface F {
    kind: "F";
  }
  
  export function decodeF(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("F", [], [], input);
  }
  
  export interface None {
    kind: "None";
  }
  
  export function decodeNone(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("None", [], [], input);
  }
  
}

