// Generated by morphir-elm

import * as codecs from "./../../../../morphir/internal/Codecs";

export namespace Morphir_Reference_Model_Issues_Issue333 {
  export type LocalDate = Invalid | Valid;

  export function decodeLocalDate(input: any): LocalDate {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "Invalid":
        return decodeInvalid(input);
      case "Valid":
        return decodeValid(input);
    }
    codecs.raiseDecodeErrorFromCustomType("LocalDate", kind);
  }

  export function encodeLocalDate(value: LocalDate): any {
    switch (value.kind) {
      case "Invalid":
        return encodeInvalid(value);
      case "Valid":
        return encodeValid(value);
    }
  }

  export class Invalid {
    kind: "Invalid" = "Invalid";

    constructor(
      public arg1: Morphir_Reference_Model_Issues_Issue333.RawLocalDate
    ) {}
  }

  export function decodeInvalid(input: any): Invalid {
    codecs.preprocessCustomTypeVariant("Invalid", 1, input);
    return new Invalid(
      Morphir_Reference_Model_Issues_Issue333.decodeRawLocalDate(input[1])
    );
  }

  export function encodeInvalid(value: Invalid): any {
    return [
      value.kind,
      Morphir_Reference_Model_Issues_Issue333.encodeRawLocalDate(value.arg1),
    ];
  }

  export class Valid {
    kind: "Valid" = "Valid";

    constructor(
      public arg1: Morphir_Reference_Model_Issues_Issue333.ValidLocalDate
    ) {}
  }

  export function decodeValid(input: any): Valid {
    codecs.preprocessCustomTypeVariant("Valid", 1, input);
    return new Valid(
      Morphir_Reference_Model_Issues_Issue333.decodeValidLocalDate(input[1])
    );
  }

  export function encodeValid(value: Valid): any {
    return [
      value.kind,
      Morphir_Reference_Model_Issues_Issue333.encodeValidLocalDate(value.arg1),
    ];
  }

  export type Month =
    | April
    | August
    | December
    | February
    | January
    | July
    | June
    | March
    | May
    | November
    | October
    | September;

  export function decodeMonth(input: any): Month {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "April":
        return decodeApril(input);
      case "August":
        return decodeAugust(input);
      case "December":
        return decodeDecember(input);
      case "February":
        return decodeFebruary(input);
      case "January":
        return decodeJanuary(input);
      case "July":
        return decodeJuly(input);
      case "June":
        return decodeJune(input);
      case "March":
        return decodeMarch(input);
      case "May":
        return decodeMay(input);
      case "November":
        return decodeNovember(input);
      case "October":
        return decodeOctober(input);
      case "September":
        return decodeSeptember(input);
    }
    codecs.raiseDecodeErrorFromCustomType("Month", kind);
  }

  export function encodeMonth(value: Month): any {
    switch (value.kind) {
      case "April":
        return encodeApril(value);
      case "August":
        return encodeAugust(value);
      case "December":
        return encodeDecember(value);
      case "February":
        return encodeFebruary(value);
      case "January":
        return encodeJanuary(value);
      case "July":
        return encodeJuly(value);
      case "June":
        return encodeJune(value);
      case "March":
        return encodeMarch(value);
      case "May":
        return encodeMay(value);
      case "November":
        return encodeNovember(value);
      case "October":
        return encodeOctober(value);
      case "September":
        return encodeSeptember(value);
    }
  }

  export class April {
    kind: "April" = "April";

    constructor() {}
  }

  export function decodeApril(input: any): April {
    codecs.preprocessCustomTypeVariant("April", 0, input);
    return new April();
  }

  export function encodeApril(value: April): any {
    return value.kind;
  }

  export class August {
    kind: "August" = "August";

    constructor() {}
  }

  export function decodeAugust(input: any): August {
    codecs.preprocessCustomTypeVariant("August", 0, input);
    return new August();
  }

  export function encodeAugust(value: August): any {
    return value.kind;
  }

  export class December {
    kind: "December" = "December";

    constructor() {}
  }

  export function decodeDecember(input: any): December {
    codecs.preprocessCustomTypeVariant("December", 0, input);
    return new December();
  }

  export function encodeDecember(value: December): any {
    return value.kind;
  }

  export class February {
    kind: "February" = "February";

    constructor() {}
  }

  export function decodeFebruary(input: any): February {
    codecs.preprocessCustomTypeVariant("February", 0, input);
    return new February();
  }

  export function encodeFebruary(value: February): any {
    return value.kind;
  }

  export class January {
    kind: "January" = "January";

    constructor() {}
  }

  export function decodeJanuary(input: any): January {
    codecs.preprocessCustomTypeVariant("January", 0, input);
    return new January();
  }

  export function encodeJanuary(value: January): any {
    return value.kind;
  }

  export class July {
    kind: "July" = "July";

    constructor() {}
  }

  export function decodeJuly(input: any): July {
    codecs.preprocessCustomTypeVariant("July", 0, input);
    return new July();
  }

  export function encodeJuly(value: July): any {
    return value.kind;
  }

  export class June {
    kind: "June" = "June";

    constructor() {}
  }

  export function decodeJune(input: any): June {
    codecs.preprocessCustomTypeVariant("June", 0, input);
    return new June();
  }

  export function encodeJune(value: June): any {
    return value.kind;
  }

  export class March {
    kind: "March" = "March";

    constructor() {}
  }

  export function decodeMarch(input: any): March {
    codecs.preprocessCustomTypeVariant("March", 0, input);
    return new March();
  }

  export function encodeMarch(value: March): any {
    return value.kind;
  }

  export class May {
    kind: "May" = "May";

    constructor() {}
  }

  export function decodeMay(input: any): May {
    codecs.preprocessCustomTypeVariant("May", 0, input);
    return new May();
  }

  export function encodeMay(value: May): any {
    return value.kind;
  }

  export class November {
    kind: "November" = "November";

    constructor() {}
  }

  export function decodeNovember(input: any): November {
    codecs.preprocessCustomTypeVariant("November", 0, input);
    return new November();
  }

  export function encodeNovember(value: November): any {
    return value.kind;
  }

  export class October {
    kind: "October" = "October";

    constructor() {}
  }

  export function decodeOctober(input: any): October {
    codecs.preprocessCustomTypeVariant("October", 0, input);
    return new October();
  }

  export function encodeOctober(value: October): any {
    return value.kind;
  }

  export class September {
    kind: "September" = "September";

    constructor() {}
  }

  export function decodeSeptember(input: any): September {
    codecs.preprocessCustomTypeVariant("September", 0, input);
    return new September();
  }

  export function encodeSeptember(value: September): any {
    return value.kind;
  }

  export type MonthParseError = InvalidMonth;

  export function decodeMonthParseError(input: any): MonthParseError {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "InvalidMonth":
        return decodeInvalidMonth(input);
    }
    codecs.raiseDecodeErrorFromCustomType("MonthParseError", kind);
  }

  export function encodeMonthParseError(value: MonthParseError): any {
    switch (value.kind) {
      case "InvalidMonth":
        return encodeInvalidMonth(value);
    }
  }

  export class InvalidMonth {
    kind: "InvalidMonth" = "InvalidMonth";

    constructor(public arg1: number) {}
  }

  export function decodeInvalidMonth(input: any): InvalidMonth {
    codecs.preprocessCustomTypeVariant("InvalidMonth", 1, input);
    return new InvalidMonth(codecs.decodeInt(input[1]));
  }

  export function encodeInvalidMonth(value: InvalidMonth): any {
    return [value.kind, codecs.encodeInt(value.arg1)];
  }

  export type RawLocalDate = {
    year: number;
    month: number;
    day: number;
  };

  export function decodeRawLocalDate(input: any): RawLocalDate {
    return codecs.decodeRecord(
      codecs.buildCodecMap([
        ["year", codecs.decodeInt],
        ["month", codecs.decodeInt],
        ["day", codecs.decodeInt],
      ]),
      input
    );
  }

  export function encodeRawLocalDate(value: RawLocalDate): any {
    return codecs.encodeRecord(
      codecs.buildCodecMap([
        ["year", codecs.encodeInt],
        ["month", codecs.encodeInt],
        ["day", codecs.encodeInt],
      ]),
      value
    );
  }

  export type ValidLocalDate = {
    year: number;
    month: Morphir_Reference_Model_Issues_Issue333.Month;
    day: number;
  };

  export function decodeValidLocalDate(input: any): ValidLocalDate {
    return codecs.decodeRecord(
      codecs.buildCodecMap([
        ["year", codecs.decodeInt],
        ["month", Morphir_Reference_Model_Issues_Issue333.decodeMonth],
        ["day", codecs.decodeInt],
      ]),
      input
    );
  }

  export function encodeValidLocalDate(value: ValidLocalDate): any {
    return codecs.encodeRecord(
      codecs.buildCodecMap([
        ["year", codecs.encodeInt],
        ["month", Morphir_Reference_Model_Issues_Issue333.encodeMonth],
        ["day", codecs.encodeInt],
      ]),
      value
    );
  }
}
