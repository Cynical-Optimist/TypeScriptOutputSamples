// Generated by morphir-elm

import * as codecs from "./../../morphir/internal/Codecs"
import { Morphir_IR_AccessControlled } from "./../../morphir/ir/AccessControlled"
import { Morphir_IR_FQName } from "./../../morphir/ir/FQName"
import { Morphir_IR_Name } from "./../../morphir/ir/Name"

export namespace Morphir_IR_Type {
  /* Constructors in a dictionary keyed by their name. The values are the argument types for each constructor.
  */
  export type Constructors<a> = Array<[Morphir_IR_Name.Name, Array<[Morphir_IR_Name.Name, Morphir_IR_Type.Type<a>]>]>
  
  export function decodeConstructors(varDecoders, input) {
  return codecs.decodeDict(Morphir_IR_Name.decodeName.bind(null, varDecoders), codecs.decodeList.bind(null, codecs.decodeTuple.bind(null, [Morphir_IR_Name.decodeName.bind(null, varDecoders), Morphir_IR_Type.decodeType.bind(null, varDecoders)])), input);
  }
  
  export function encodeConstructors(varEncoders, value) {
  return codecs.encodeDict(codecs.encodeUnit.bind(null), codecs.encodeList.bind(null, codecs.encodeTuple.bind(null, [codecs.encodeUnit.bind(null), codecs.encodeUnit.bind(null)])), value);
  }
  
  /* This syntax represents a type definition. For example:
  
    - `type alias Foo a = {bar : Maybe a, qux : Int}`
    - `type MyList a = End | Cons a (MyList a)`
  
  In the definition, the `List Name` refers to type parameters on the LHS
  and `Type extra` refers to the RHS
  
  */
  export type Definition<a> = CustomTypeDefinition<a> | TypeAliasDefinition<a>
  
  export function decodeDefinition(varDecoders, input) {
  let decoderMap = new Map();
  decoderMap.set("CustomTypeDefinition", decodeCustomTypeDefinition.bind(varDecoders));
  decoderMap.set("TypeAliasDefinition", decodeTypeAliasDefinition.bind(varDecoders));
  codecs.decodeCustomType(decoderMap, input);
  }
  
  
  
  export interface CustomTypeDefinition<a> {
    kind: "CustomTypeDefinition";
    arg1: Array<Morphir_IR_Name.Name>;
    arg2: Morphir_IR_AccessControlled.AccessControlled<Morphir_IR_Type.Constructors<a>>;
  }
  
  export function decodeCustomTypeDefinition(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("CustomTypeDefinition", ["Arg1", "Arg2"], [codecs.decodeList.bind(null, Morphir_IR_Name.decodeName.bind(null, varDecoders)), Morphir_IR_AccessControlled.decodeAccessControlled.bind(null, varDecoders)], input);
  }
  
  export interface TypeAliasDefinition<a> {
    kind: "TypeAliasDefinition";
    arg1: Array<Morphir_IR_Name.Name>;
    arg2: Morphir_IR_Type.Type<a>;
  }
  
  export function decodeTypeAliasDefinition(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("TypeAliasDefinition", ["Arg1", "Arg2"], [codecs.decodeList.bind(null, Morphir_IR_Name.decodeName.bind(null, varDecoders)), Morphir_IR_Type.decodeType.bind(null, varDecoders)], input);
  }
  
  /* An opaque representation of a field. It's made up of a name and a type.
  */
  export type Field<a> = {
    name: Morphir_IR_Name.Name;
    tpe: Morphir_IR_Type.Type<a>;
  }
  
  export function decodeField(varDecoders, input) {
  return codecs.decodeRecord(new Map([["name", Morphir_IR_Name.decodeName.bind(null, varDecoders)], ["tpe", Morphir_IR_Type.decodeType.bind(null, varDecoders)]]), input);
  }
  
  export function encodeField(varEncoders, value) {
  return codecs.encodeRecord(new Map([["name", codecs.encodeUnit.bind(null)], ["tpe", codecs.encodeUnit.bind(null)]]), value);
  }
  
  /* */
  export type Specification<a> = CustomTypeSpecification<a> | OpaqueTypeSpecification<a> | TypeAliasSpecification<a>
  
  export function decodeSpecification(varDecoders, input) {
  let decoderMap = new Map();
  decoderMap.set("CustomTypeSpecification", decodeCustomTypeSpecification.bind(varDecoders));
  decoderMap.set("OpaqueTypeSpecification", decodeOpaqueTypeSpecification.bind(varDecoders));
  decoderMap.set("TypeAliasSpecification", decodeTypeAliasSpecification.bind(varDecoders));
  codecs.decodeCustomType(decoderMap, input);
  }
  
  
  
  export interface CustomTypeSpecification<a> {
    kind: "CustomTypeSpecification";
    arg1: Array<Morphir_IR_Name.Name>;
    arg2: Morphir_IR_Type.Constructors<a>;
  }
  
  export function decodeCustomTypeSpecification(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("CustomTypeSpecification", ["Arg1", "Arg2"], [codecs.decodeList.bind(null, Morphir_IR_Name.decodeName.bind(null, varDecoders)), Morphir_IR_Type.decodeConstructors.bind(null, varDecoders)], input);
  }
  
  export interface OpaqueTypeSpecification<a> {
    kind: "OpaqueTypeSpecification";
    arg1: Array<Morphir_IR_Name.Name>;
  }
  
  export function decodeOpaqueTypeSpecification(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("OpaqueTypeSpecification", ["Arg1"], [codecs.decodeList.bind(null, Morphir_IR_Name.decodeName.bind(null, varDecoders))], input);
  }
  
  export interface TypeAliasSpecification<a> {
    kind: "TypeAliasSpecification";
    arg1: Array<Morphir_IR_Name.Name>;
    arg2: Morphir_IR_Type.Type<a>;
  }
  
  export function decodeTypeAliasSpecification(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("TypeAliasSpecification", ["Arg1", "Arg2"], [codecs.decodeList.bind(null, Morphir_IR_Name.decodeName.bind(null, varDecoders)), Morphir_IR_Type.decodeType.bind(null, varDecoders)], input);
  }
  
  /* Represents a type expression that can appear in various places within the IR. It can be the right-hand-side of
  a type alias declaration, input and output types of a function or as an annotation on values after type inference is
  done.
  
  Type are modeled as expression trees: a recursive data structure with various node types. The type argument `a` allows
  us to assign some additional attributes to each node in the tree. Here are some details on each node type in the tree:
  
    - **Variable**
        - Represents a type variable.
        - It has a single argument which captures the name of the variable.
        - [Wikipedia: Type variable](https://en.wikipedia.org/wiki/Type_variable)
        - [creation](#variable), [matching](#matchVariable)
    - **Reference**
        - A fully-qualified reference to some other type or type alias within the package or one of its dependencies.
        - References to built-in types (like `Int`, `String`, ...) don't have an associated definition.
        - [creation](#reference), [matching](#matchReference)
    - **Tuple**
        - A tuple is a composition of other types (potentially other tuples).
        - The order of types is relevant so the easiest way to think about it is as a list of types.
        - A tuple can have any number of elements and there is no restriction on the element types.
        - A tuple with zero elements is equivalent with `Unit`.
        - A tuple with a single element is equivalent to the element type itself.
        - [Wikipedia: Tuple](https://en.wikipedia.org/wiki/Tuple)
        - [creation](#tuple), [matching](#matchTuple)
    - **Record**
        - A record is a composition of other types like tuples but types are identified by a field name instead of an index.
        - The best way to think of a record is as a dictionary of types.
        - Our representation captures the order of fields for convenience but the order should not be considered for type
          equivalence.
        - [Wikipedia: Record](https://en.wikipedia.org/wiki/Record_(computer_science))
        - [Elm-lang: Records](https://elm-lang.org/docs/records)
        - Utilities: [creation](#record), [matching](#matchRecord)
    - **ExtensibleRecord**
        - Similar to records but while record types declare that the underlying object has "exactly these fields" an
          extensible record declares that the object has "at least these fields".
        - Besides the list of fields you need to specify a variable name that will be used to abstract over the type
          that's being extended.
        - [Elm: Extensible records](https://ckoster22.medium.com/advanced-types-in-elm-extensible-records-67e9d804030d)
        - [creation](#extensibleRecord), [matching](#matchExtensibleRecord)
    - **Function**
        - Represents the type of a function. The two arguments are the argument and the return type of the function.
        - Multi-argument functions are represented by composing functions:
            - `a -> b -> c` is represented as `a -> (b -> c)`
        - [Wikipedia: Function type](https://en.wikipedia.org/wiki/Function_type)
        - [creation](#function), [matching](#matchFunction)
    - **Unit**
        - Unit type is used as a placeholder in situations where a type is required but the corresponding value is unused.
        - Semantically the unit type represents a set that has exactly one value which is often called unit.
        - Unit corresponds to void in some other programming languages.
        - [Wikipedia: Unit type](https://en.wikipedia.org/wiki/Unit_type)
        - [creation](#unit), [matching](#matchUnit)
  
  */
  export type Type<a> = ExtensibleRecord<a> | Function<a> | Record<a> | Reference<a> | Tuple<a> | Unit<a> | Variable<a>
  
  export function decodeType(varDecoders, input) {
  let decoderMap = new Map();
  decoderMap.set("ExtensibleRecord", decodeExtensibleRecord.bind(varDecoders));
  decoderMap.set("Function", decodeFunction.bind(varDecoders));
  decoderMap.set("Record", decodeRecord.bind(varDecoders));
  decoderMap.set("Reference", decodeReference.bind(varDecoders));
  decoderMap.set("Tuple", decodeTuple.bind(varDecoders));
  decoderMap.set("Unit", decodeUnit.bind(varDecoders));
  decoderMap.set("Variable", decodeVariable.bind(varDecoders));
  codecs.decodeCustomType(decoderMap, input);
  }
  
  
  
  export interface ExtensibleRecord<a> {
    kind: "ExtensibleRecord";
    arg1: a;
    arg2: Morphir_IR_Name.Name;
    arg3: Array<Morphir_IR_Type.Field<a>>;
  }
  
  export function decodeExtensibleRecord(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("ExtensibleRecord", ["Arg1", "Arg2", "Arg3"], [varDecoders.A.bind(null), Morphir_IR_Name.decodeName.bind(null, varDecoders), codecs.decodeList.bind(null, Morphir_IR_Type.decodeField.bind(null, varDecoders))], input);
  }
  
  export interface Function<a> {
    kind: "Function";
    arg1: a;
    arg2: Morphir_IR_Type.Type<a>;
    arg3: Morphir_IR_Type.Type<a>;
  }
  
  export function decodeFunction(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Function", ["Arg1", "Arg2", "Arg3"], [varDecoders.A.bind(null), Morphir_IR_Type.decodeType.bind(null, varDecoders), Morphir_IR_Type.decodeType.bind(null, varDecoders)], input);
  }
  
  export interface Record<a> {
    kind: "Record";
    arg1: a;
    arg2: Array<Morphir_IR_Type.Field<a>>;
  }
  
  export function decodeRecord(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Record", ["Arg1", "Arg2"], [varDecoders.A.bind(null), codecs.decodeList.bind(null, Morphir_IR_Type.decodeField.bind(null, varDecoders))], input);
  }
  
  export interface Reference<a> {
    kind: "Reference";
    arg1: a;
    arg2: Morphir_IR_FQName.FQName;
    arg3: Array<Morphir_IR_Type.Type<a>>;
  }
  
  export function decodeReference(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Reference", ["Arg1", "Arg2", "Arg3"], [varDecoders.A.bind(null), Morphir_IR_FQName.decodeFQName.bind(null, varDecoders), codecs.decodeList.bind(null, Morphir_IR_Type.decodeType.bind(null, varDecoders))], input);
  }
  
  export interface Tuple<a> {
    kind: "Tuple";
    arg1: a;
    arg2: Array<Morphir_IR_Type.Type<a>>;
  }
  
  export function decodeTuple(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Tuple", ["Arg1", "Arg2"], [varDecoders.A.bind(null), codecs.decodeList.bind(null, Morphir_IR_Type.decodeType.bind(null, varDecoders))], input);
  }
  
  export interface Unit<a> {
    kind: "Unit";
    arg1: a;
  }
  
  export function decodeUnit(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Unit", ["Arg1"], [varDecoders.A.bind(null)], input);
  }
  
  export interface Variable<a> {
    kind: "Variable";
    arg1: a;
    arg2: Morphir_IR_Name.Name;
  }
  
  export function decodeVariable(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Variable", ["Arg1", "Arg2"], [varDecoders.A.bind(null), Morphir_IR_Name.decodeName.bind(null, varDecoders)], input);
  }
  
}

