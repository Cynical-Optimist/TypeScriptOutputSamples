// Generated by morphir-elm

import * as codecs from "./../../morphir/internal/Codecs";
import { Morphir_IR_AccessControlled } from "./../../morphir/ir/AccessControlled";
import { Morphir_IR_FQName } from "./../../morphir/ir/FQName";
import { Morphir_IR_Name } from "./../../morphir/ir/Name";

export namespace Morphir_IR_Type {
  /* Constructors in a dictionary keyed by their name. The values are the argument types for each constructor.
   */
  export type Constructors<A> = Map<
    Morphir_IR_Name.Name,
    Array<[Morphir_IR_Name.Name, Morphir_IR_Type.Type<A>]>
  >;

  export function decodeConstructors<A>(
    decodeA: (input: any) => A,
    input: any
  ): Constructors<A> {
    return codecs.decodeDict(
      Morphir_IR_Name.decodeName,
      codecs.decodeList.bind(
        null,
        codecs.decodeTuple.bind(null, [
          Morphir_IR_Name.decodeName,
          Morphir_IR_Type.decodeType.bind(null, decodeA),
        ])
      ),
      input
    );
  }

  export function encodeConstructors<A>(
    encodeA: (value: A) => any,
    value: Constructors<A>
  ): any {
    return codecs.encodeDict(
      Morphir_IR_Name.encodeName,
      codecs.encodeList.bind(
        null,
        codecs.encodeTuple.bind(null, [
          Morphir_IR_Name.encodeName,
          Morphir_IR_Type.encodeType.bind(null, encodeA),
        ])
      ),
      value
    );
  }

  /* This syntax represents a type definition. For example:
  
    - `type alias Foo a = {bar : Maybe a, qux : Int}`
    - `type MyList a = End | Cons a (MyList a)`
  
  In the definition, the `List Name` refers to type parameters on the LHS
  and `Type extra` refers to the RHS
  
  */
  export type Definition<A> = CustomTypeDefinition<A> | TypeAliasDefinition<A>;

  export function decodeDefinition<A>(
    decodeA: (input: any) => A,
    input: any
  ): Definition<A> {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "CustomTypeDefinition":
        return decodeCustomTypeDefinition(decodeA, input);
      case "TypeAliasDefinition":
        return decodeTypeAliasDefinition(decodeA, input);
    }
    codecs.raiseDecodeErrorFromCustomType("Definition", kind);
  }

  export function encodeDefinition<A>(
    encodeA: (value: A) => any,
    value: Definition<A>
  ): any {
    switch (value.kind) {
      case "CustomTypeDefinition":
        return encodeCustomTypeDefinition(encodeA, value);
      case "TypeAliasDefinition":
        return encodeTypeAliasDefinition(encodeA, value);
    }
  }

  export class CustomTypeDefinition<A> {
    kind: "CustomTypeDefinition" = "CustomTypeDefinition";

    constructor(
      public arg1: Array<Morphir_IR_Name.Name>,
      public arg2: Morphir_IR_AccessControlled.AccessControlled<
        Morphir_IR_Type.Constructors<A>
      >
    ) {}
  }

  export function decodeCustomTypeDefinition<A>(
    decodeA: (input: any) => A,
    input: any
  ): CustomTypeDefinition<A> {
    codecs.preprocessCustomTypeVariant("CustomTypeDefinition", 2, input);
    return new CustomTypeDefinition(
      codecs.decodeList(Morphir_IR_Name.decodeName, input[1]),
      Morphir_IR_AccessControlled.decodeAccessControlled(
        Morphir_IR_Type.decodeConstructors.bind(null, decodeA),
        input[2]
      )
    );
  }

  export function encodeCustomTypeDefinition<A>(
    encodeA: (value: A) => any,
    value: CustomTypeDefinition<A>
  ): any {
    return [
      value.kind,
      codecs.encodeList(Morphir_IR_Name.encodeName, value.arg1),
      Morphir_IR_AccessControlled.encodeAccessControlled(
        Morphir_IR_Type.encodeConstructors.bind(null, encodeA),
        value.arg2
      ),
    ];
  }

  export class TypeAliasDefinition<A> {
    kind: "TypeAliasDefinition" = "TypeAliasDefinition";

    constructor(
      public arg1: Array<Morphir_IR_Name.Name>,
      public arg2: Morphir_IR_Type.Type<A>
    ) {}
  }

  export function decodeTypeAliasDefinition<A>(
    decodeA: (input: any) => A,
    input: any
  ): TypeAliasDefinition<A> {
    codecs.preprocessCustomTypeVariant("TypeAliasDefinition", 2, input);
    return new TypeAliasDefinition(
      codecs.decodeList(Morphir_IR_Name.decodeName, input[1]),
      Morphir_IR_Type.decodeType(decodeA, input[2])
    );
  }

  export function encodeTypeAliasDefinition<A>(
    encodeA: (value: A) => any,
    value: TypeAliasDefinition<A>
  ): any {
    return [
      value.kind,
      codecs.encodeList(Morphir_IR_Name.encodeName, value.arg1),
      Morphir_IR_Type.encodeType(encodeA, value.arg2),
    ];
  }

  /* An opaque representation of a field. It's made up of a name and a type.
   */
  export type Field<A> = {
    name: Morphir_IR_Name.Name;
    tpe: Morphir_IR_Type.Type<A>;
  };

  export function decodeField<A>(
    decodeA: (input: any) => A,
    input: any
  ): Field<A> {
    return codecs.decodeRecord(
      codecs.buildCodecMap([
        ["name", Morphir_IR_Name.decodeName],
        ["tpe", Morphir_IR_Type.decodeType.bind(null, decodeA)],
      ]),
      input
    );
  }

  export function encodeField<A>(
    encodeA: (value: A) => any,
    value: Field<A>
  ): any {
    return codecs.encodeRecord(
      codecs.buildCodecMap([
        ["name", Morphir_IR_Name.encodeName],
        ["tpe", Morphir_IR_Type.encodeType.bind(null, encodeA)],
      ]),
      value
    );
  }

  /* */
  export type Specification<A> =
    | CustomTypeSpecification<A>
    | OpaqueTypeSpecification
    | TypeAliasSpecification<A>;

  export function decodeSpecification<A>(
    decodeA: (input: any) => A,
    input: any
  ): Specification<A> {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "CustomTypeSpecification":
        return decodeCustomTypeSpecification(decodeA, input);
      case "OpaqueTypeSpecification":
        return decodeOpaqueTypeSpecification(input);
      case "TypeAliasSpecification":
        return decodeTypeAliasSpecification(decodeA, input);
    }
    codecs.raiseDecodeErrorFromCustomType("Specification", kind);
  }

  export function encodeSpecification<A>(
    encodeA: (value: A) => any,
    value: Specification<A>
  ): any {
    switch (value.kind) {
      case "CustomTypeSpecification":
        return encodeCustomTypeSpecification(encodeA, value);
      case "OpaqueTypeSpecification":
        return encodeOpaqueTypeSpecification(value);
      case "TypeAliasSpecification":
        return encodeTypeAliasSpecification(encodeA, value);
    }
  }

  export class CustomTypeSpecification<A> {
    kind: "CustomTypeSpecification" = "CustomTypeSpecification";

    constructor(
      public arg1: Array<Morphir_IR_Name.Name>,
      public arg2: Morphir_IR_Type.Constructors<A>
    ) {}
  }

  export function decodeCustomTypeSpecification<A>(
    decodeA: (input: any) => A,
    input: any
  ): CustomTypeSpecification<A> {
    codecs.preprocessCustomTypeVariant("CustomTypeSpecification", 2, input);
    return new CustomTypeSpecification(
      codecs.decodeList(Morphir_IR_Name.decodeName, input[1]),
      Morphir_IR_Type.decodeConstructors(decodeA, input[2])
    );
  }

  export function encodeCustomTypeSpecification<A>(
    encodeA: (value: A) => any,
    value: CustomTypeSpecification<A>
  ): any {
    return [
      value.kind,
      codecs.encodeList(Morphir_IR_Name.encodeName, value.arg1),
      Morphir_IR_Type.encodeConstructors(encodeA, value.arg2),
    ];
  }

  export class OpaqueTypeSpecification {
    kind: "OpaqueTypeSpecification" = "OpaqueTypeSpecification";

    constructor(public arg1: Array<Morphir_IR_Name.Name>) {}
  }

  export function decodeOpaqueTypeSpecification(
    input: any
  ): OpaqueTypeSpecification {
    codecs.preprocessCustomTypeVariant("OpaqueTypeSpecification", 1, input);
    return new OpaqueTypeSpecification(
      codecs.decodeList(Morphir_IR_Name.decodeName, input[1])
    );
  }

  export function encodeOpaqueTypeSpecification(
    value: OpaqueTypeSpecification
  ): any {
    return [
      value.kind,
      codecs.encodeList(Morphir_IR_Name.encodeName, value.arg1),
    ];
  }

  export class TypeAliasSpecification<A> {
    kind: "TypeAliasSpecification" = "TypeAliasSpecification";

    constructor(
      public arg1: Array<Morphir_IR_Name.Name>,
      public arg2: Morphir_IR_Type.Type<A>
    ) {}
  }

  export function decodeTypeAliasSpecification<A>(
    decodeA: (input: any) => A,
    input: any
  ): TypeAliasSpecification<A> {
    codecs.preprocessCustomTypeVariant("TypeAliasSpecification", 2, input);
    return new TypeAliasSpecification(
      codecs.decodeList(Morphir_IR_Name.decodeName, input[1]),
      Morphir_IR_Type.decodeType(decodeA, input[2])
    );
  }

  export function encodeTypeAliasSpecification<A>(
    encodeA: (value: A) => any,
    value: TypeAliasSpecification<A>
  ): any {
    return [
      value.kind,
      codecs.encodeList(Morphir_IR_Name.encodeName, value.arg1),
      Morphir_IR_Type.encodeType(encodeA, value.arg2),
    ];
  }

  /* Represents a type expression that can appear in various places within the IR. It can be the right-hand-side of
  a type alias declaration, input and output types of a function or as an annotation on values after type inference is
  done.
  
  Type are modeled as expression trees: a recursive data structure with various node types. The type argument `a` allows
  us to assign some additional attributes to each node in the tree. Here are some details on each node type in the tree:
  
    - **Variable**
        - Represents a type variable.
        - It has a single argument which captures the name of the variable.
        - [Wikipedia: Type variable](https://en.wikipedia.org/wiki/Type_variable)
        - [creation](#variable), [matching](#matchVariable)
    - **Reference**
        - A fully-qualified reference to some other type or type alias within the package or one of its dependencies.
        - References to built-in types (like `Int`, `String`, ...) don't have an associated definition.
        - [creation](#reference), [matching](#matchReference)
    - **Tuple**
        - A tuple is a composition of other types (potentially other tuples).
        - The order of types is relevant so the easiest way to think about it is as a list of types.
        - A tuple can have any number of elements and there is no restriction on the element types.
        - A tuple with zero elements is equivalent with `Unit`.
        - A tuple with a single element is equivalent to the element type itself.
        - [Wikipedia: Tuple](https://en.wikipedia.org/wiki/Tuple)
        - [creation](#tuple), [matching](#matchTuple)
    - **Record**
        - A record is a composition of other types like tuples but types are identified by a field name instead of an index.
        - The best way to think of a record is as a dictionary of types.
        - Our representation captures the order of fields for convenience but the order should not be considered for type
          equivalence.
        - [Wikipedia: Record](https://en.wikipedia.org/wiki/Record_(computer_science))
        - [Elm-lang: Records](https://elm-lang.org/docs/records)
        - Utilities: [creation](#record), [matching](#matchRecord)
    - **ExtensibleRecord**
        - Similar to records but while record types declare that the underlying object has "exactly these fields" an
          extensible record declares that the object has "at least these fields".
        - Besides the list of fields you need to specify a variable name that will be used to abstract over the type
          that's being extended.
        - [Elm: Extensible records](https://ckoster22.medium.com/advanced-types-in-elm-extensible-records-67e9d804030d)
        - [creation](#extensibleRecord), [matching](#matchExtensibleRecord)
    - **Function**
        - Represents the type of a function. The two arguments are the argument and the return type of the function.
        - Multi-argument functions are represented by composing functions:
            - `a -> b -> c` is represented as `a -> (b -> c)`
        - [Wikipedia: Function type](https://en.wikipedia.org/wiki/Function_type)
        - [creation](#function), [matching](#matchFunction)
    - **Unit**
        - Unit type is used as a placeholder in situations where a type is required but the corresponding value is unused.
        - Semantically the unit type represents a set that has exactly one value which is often called unit.
        - Unit corresponds to void in some other programming languages.
        - [Wikipedia: Unit type](https://en.wikipedia.org/wiki/Unit_type)
        - [creation](#unit), [matching](#matchUnit)
  
  */
  export type Type<A> =
    | ExtensibleRecord<A>
    | Function<A>
    | Record<A>
    | Reference<A>
    | Tuple<A>
    | Unit<A>
    | Variable<A>;

  export function decodeType<A>(
    decodeA: (input: any) => A,
    input: any
  ): Type<A> {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "ExtensibleRecord":
        return decodeExtensibleRecord(decodeA, input);
      case "Function":
        return decodeFunction(decodeA, input);
      case "Record":
        return decodeRecord(decodeA, input);
      case "Reference":
        return decodeReference(decodeA, input);
      case "Tuple":
        return decodeTuple(decodeA, input);
      case "Unit":
        return decodeUnit(decodeA, input);
      case "Variable":
        return decodeVariable(decodeA, input);
    }
    codecs.raiseDecodeErrorFromCustomType("Type", kind);
  }

  export function encodeType<A>(
    encodeA: (value: A) => any,
    value: Type<A>
  ): any {
    switch (value.kind) {
      case "ExtensibleRecord":
        return encodeExtensibleRecord(encodeA, value);
      case "Function":
        return encodeFunction(encodeA, value);
      case "Record":
        return encodeRecord(encodeA, value);
      case "Reference":
        return encodeReference(encodeA, value);
      case "Tuple":
        return encodeTuple(encodeA, value);
      case "Unit":
        return encodeUnit(encodeA, value);
      case "Variable":
        return encodeVariable(encodeA, value);
    }
  }

  export class ExtensibleRecord<A> {
    kind: "ExtensibleRecord" = "ExtensibleRecord";

    constructor(
      public arg1: A,
      public arg2: Morphir_IR_Name.Name,
      public arg3: Array<Morphir_IR_Type.Field<A>>
    ) {}
  }

  export function decodeExtensibleRecord<A>(
    decodeA: (input: any) => A,
    input: any
  ): ExtensibleRecord<A> {
    codecs.preprocessCustomTypeVariant("ExtensibleRecord", 3, input);
    return new ExtensibleRecord(
      decodeA(input[1]),
      Morphir_IR_Name.decodeName(input[2]),
      codecs.decodeList(
        Morphir_IR_Type.decodeField.bind(null, decodeA),
        input[3]
      )
    );
  }

  export function encodeExtensibleRecord<A>(
    encodeA: (value: A) => any,
    value: ExtensibleRecord<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_Name.encodeName(value.arg2),
      codecs.encodeList(
        Morphir_IR_Type.encodeField.bind(null, encodeA),
        value.arg3
      ),
    ];
  }

  export class Function<A> {
    kind: "Function" = "Function";

    constructor(
      public arg1: A,
      public arg2: Morphir_IR_Type.Type<A>,
      public arg3: Morphir_IR_Type.Type<A>
    ) {}
  }

  export function decodeFunction<A>(
    decodeA: (input: any) => A,
    input: any
  ): Function<A> {
    codecs.preprocessCustomTypeVariant("Function", 3, input);
    return new Function(
      decodeA(input[1]),
      Morphir_IR_Type.decodeType(decodeA, input[2]),
      Morphir_IR_Type.decodeType(decodeA, input[3])
    );
  }

  export function encodeFunction<A>(
    encodeA: (value: A) => any,
    value: Function<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_Type.encodeType(encodeA, value.arg2),
      Morphir_IR_Type.encodeType(encodeA, value.arg3),
    ];
  }

  export class Record<A> {
    kind: "Record" = "Record";

    constructor(public arg1: A, public arg2: Array<Morphir_IR_Type.Field<A>>) {}
  }

  export function decodeRecord<A>(
    decodeA: (input: any) => A,
    input: any
  ): Record<A> {
    codecs.preprocessCustomTypeVariant("Record", 2, input);
    return new Record(
      decodeA(input[1]),
      codecs.decodeList(
        Morphir_IR_Type.decodeField.bind(null, decodeA),
        input[2]
      )
    );
  }

  export function encodeRecord<A>(
    encodeA: (value: A) => any,
    value: Record<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      codecs.encodeList(
        Morphir_IR_Type.encodeField.bind(null, encodeA),
        value.arg2
      ),
    ];
  }

  export class Reference<A> {
    kind: "Reference" = "Reference";

    constructor(
      public arg1: A,
      public arg2: Morphir_IR_FQName.FQName,
      public arg3: Array<Morphir_IR_Type.Type<A>>
    ) {}
  }

  export function decodeReference<A>(
    decodeA: (input: any) => A,
    input: any
  ): Reference<A> {
    codecs.preprocessCustomTypeVariant("Reference", 3, input);
    return new Reference(
      decodeA(input[1]),
      Morphir_IR_FQName.decodeFQName(input[2]),
      codecs.decodeList(
        Morphir_IR_Type.decodeType.bind(null, decodeA),
        input[3]
      )
    );
  }

  export function encodeReference<A>(
    encodeA: (value: A) => any,
    value: Reference<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_FQName.encodeFQName(value.arg2),
      codecs.encodeList(
        Morphir_IR_Type.encodeType.bind(null, encodeA),
        value.arg3
      ),
    ];
  }

  export class Tuple<A> {
    kind: "Tuple" = "Tuple";

    constructor(public arg1: A, public arg2: Array<Morphir_IR_Type.Type<A>>) {}
  }

  export function decodeTuple<A>(
    decodeA: (input: any) => A,
    input: any
  ): Tuple<A> {
    codecs.preprocessCustomTypeVariant("Tuple", 2, input);
    return new Tuple(
      decodeA(input[1]),
      codecs.decodeList(
        Morphir_IR_Type.decodeType.bind(null, decodeA),
        input[2]
      )
    );
  }

  export function encodeTuple<A>(
    encodeA: (value: A) => any,
    value: Tuple<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      codecs.encodeList(
        Morphir_IR_Type.encodeType.bind(null, encodeA),
        value.arg2
      ),
    ];
  }

  export class Unit<A> {
    kind: "Unit" = "Unit";

    constructor(public arg1: A) {}
  }

  export function decodeUnit<A>(
    decodeA: (input: any) => A,
    input: any
  ): Unit<A> {
    codecs.preprocessCustomTypeVariant("Unit", 1, input);
    return new Unit(decodeA(input[1]));
  }

  export function encodeUnit<A>(
    encodeA: (value: A) => any,
    value: Unit<A>
  ): any {
    return [value.kind, encodeA(value.arg1)];
  }

  export class Variable<A> {
    kind: "Variable" = "Variable";

    constructor(public arg1: A, public arg2: Morphir_IR_Name.Name) {}
  }

  export function decodeVariable<A>(
    decodeA: (input: any) => A,
    input: any
  ): Variable<A> {
    codecs.preprocessCustomTypeVariant("Variable", 2, input);
    return new Variable(
      decodeA(input[1]),
      Morphir_IR_Name.decodeName(input[2])
    );
  }

  export function encodeVariable<A>(
    encodeA: (value: A) => any,
    value: Variable<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_Name.encodeName(value.arg2),
    ];
  }
}
