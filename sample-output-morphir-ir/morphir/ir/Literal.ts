// Generated by morphir-elm

import * as codecs from "./../../morphir/internal/Codecs";

export namespace Morphir_IR_Literal {
  /* Type that represents a literal value.
   */
  export type Literal =
    | BoolLiteral
    | CharLiteral
    | FloatLiteral
    | StringLiteral
    | WholeNumberLiteral;

  export function decodeLiteral(input: any): Literal {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "BoolLiteral":
        return decodeBoolLiteral(input);
      case "CharLiteral":
        return decodeCharLiteral(input);
      case "FloatLiteral":
        return decodeFloatLiteral(input);
      case "StringLiteral":
        return decodeStringLiteral(input);
      case "WholeNumberLiteral":
        return decodeWholeNumberLiteral(input);
    }
    codecs.raiseDecodeErrorFromCustomType("Literal", kind);
  }

  export function encodeLiteral(value: Literal): any {
    switch (value.kind) {
      case "BoolLiteral":
        return encodeBoolLiteral(value);
      case "CharLiteral":
        return encodeCharLiteral(value);
      case "FloatLiteral":
        return encodeFloatLiteral(value);
      case "StringLiteral":
        return encodeStringLiteral(value);
      case "WholeNumberLiteral":
        return encodeWholeNumberLiteral(value);
    }
  }

  export class BoolLiteral {
    kind: "BoolLiteral" = "BoolLiteral";

    constructor(public arg1: boolean) {}
  }

  export function decodeBoolLiteral(input: any): BoolLiteral {
    codecs.preprocessCustomTypeVariant("BoolLiteral", 1, input);
    return new BoolLiteral(codecs.decodeBoolean(input[1]));
  }

  export function encodeBoolLiteral(value: BoolLiteral): any {
    return [value.kind, codecs.encodeBoolean(value.arg1)];
  }

  export class CharLiteral {
    kind: "CharLiteral" = "CharLiteral";

    constructor(public arg1: string) {}
  }

  export function decodeCharLiteral(input: any): CharLiteral {
    codecs.preprocessCustomTypeVariant("CharLiteral", 1, input);
    return new CharLiteral(codecs.decodeChar(input[1]));
  }

  export function encodeCharLiteral(value: CharLiteral): any {
    return [value.kind, codecs.encodeChar(value.arg1)];
  }

  export class FloatLiteral {
    kind: "FloatLiteral" = "FloatLiteral";

    constructor(public arg1: number) {}
  }

  export function decodeFloatLiteral(input: any): FloatLiteral {
    codecs.preprocessCustomTypeVariant("FloatLiteral", 1, input);
    return new FloatLiteral(codecs.decodeFloat(input[1]));
  }

  export function encodeFloatLiteral(value: FloatLiteral): any {
    return [value.kind, codecs.encodeFloat(value.arg1)];
  }

  export class StringLiteral {
    kind: "StringLiteral" = "StringLiteral";

    constructor(public arg1: string) {}
  }

  export function decodeStringLiteral(input: any): StringLiteral {
    codecs.preprocessCustomTypeVariant("StringLiteral", 1, input);
    return new StringLiteral(codecs.decodeString(input[1]));
  }

  export function encodeStringLiteral(value: StringLiteral): any {
    return [value.kind, codecs.encodeString(value.arg1)];
  }

  export class WholeNumberLiteral {
    kind: "WholeNumberLiteral" = "WholeNumberLiteral";

    constructor(public arg1: number) {}
  }

  export function decodeWholeNumberLiteral(input: any): WholeNumberLiteral {
    codecs.preprocessCustomTypeVariant("WholeNumberLiteral", 1, input);
    return new WholeNumberLiteral(codecs.decodeInt(input[1]));
  }

  export function encodeWholeNumberLiteral(value: WholeNumberLiteral): any {
    return [value.kind, codecs.encodeInt(value.arg1)];
  }
}
