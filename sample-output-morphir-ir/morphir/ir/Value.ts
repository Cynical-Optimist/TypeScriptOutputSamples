// Generated by morphir-elm

import * as codecs from "./../../morphir/internal/Codecs";
import { Morphir_IR_FQName } from "./../../morphir/ir/FQName";
import { Morphir_IR_Literal } from "./../../morphir/ir/Literal";
import { Morphir_IR_Name } from "./../../morphir/ir/Name";
import { Morphir_IR_Type } from "./../../morphir/ir/Type";

export namespace Morphir_IR_Value {
  /* Type that represents a value or function definition. A definition is the actual data or logic as opposed to a specification
  which is just the specification of those. Value definitions can be typed or untyped. Exposed values have to be typed.
  */
  export type Definition<Ta, Va> = {
    inputTypes: Array<[Morphir_IR_Name.Name, Va, Morphir_IR_Type.Type<Ta>]>;
    outputType: Morphir_IR_Type.Type<Ta>;
    body: Morphir_IR_Value.Value<Ta, Va>;
  };

  export function decodeDefinition<Ta, Va>(
    decodeTa: (input: any) => Ta,
    decodeVa: (input: any) => Va,
    input: any
  ): Definition<Ta, Va> {
    return codecs.decodeRecord(
      codecs.buildCodecMap([
        [
          "inputTypes",
          codecs.decodeList.bind(
            null,
            codecs.decodeTuple.bind(null, [
              Morphir_IR_Name.decodeName,
              decodeVa,
              Morphir_IR_Type.decodeType.bind(null, decodeTa),
            ])
          ),
        ],
        ["outputType", Morphir_IR_Type.decodeType.bind(null, decodeTa)],
        ["body", Morphir_IR_Value.decodeValue.bind(null, decodeTa, decodeVa)],
      ]),
      input
    );
  }

  export function encodeDefinition<Ta, Va>(
    encodeTa: (value: Ta) => any,
    encodeVa: (value: Va) => any,
    value: Definition<Ta, Va>
  ): any {
    return codecs.encodeRecord(
      codecs.buildCodecMap([
        [
          "inputTypes",
          codecs.encodeList.bind(
            null,
            codecs.encodeTuple.bind(null, [
              Morphir_IR_Name.encodeName,
              encodeVa,
              Morphir_IR_Type.encodeType.bind(null, encodeTa),
            ])
          ),
        ],
        ["outputType", Morphir_IR_Type.encodeType.bind(null, encodeTa)],
        ["body", Morphir_IR_Value.encodeValue.bind(null, encodeTa, encodeVa)],
      ]),
      value
    );
  }

  /* Type that represents a pattern. A pattern can do two things: match on a specific shape or exact value and extract
  parts of a value into variables. It's a recursive data structure made of of the following building blocks:
  
    - **WildcardPattern**
        - Matches any value and does not extract any variables.
        - `_` in Elm
    - **AsPattern**
        - Assigns a variable name to the value matched by a nested pattern.
        - `(...) as foo` in Elm
        - Special case: when there is just a variable name in a pattern in Elm it will be represented as a
          `WildcardPattern` wrapped in an `AsPattern`
    - **TuplePattern**
        - Matches on a tuple where each element matches the nested patterns.
    - **ConstructorPattern**
        - Matches on a type constructor and its arguments.
    - **EmptyListPattern**
        - Matches on an empty list.
    - **HeadTailPattern**
        - Matches on the head and the tail of a list.
        - Combined with `EmptyListPattern` it can match on lists of any specific sizes.
    - **LiteralPattern**
        - Matches an an exact literal value.
    - **UnitPattern**
        - Matches the `Unit` value only.
  
  */
  export type Pattern<A> =
    | AsPattern<A>
    | ConstructorPattern<A>
    | EmptyListPattern<A>
    | HeadTailPattern<A>
    | LiteralPattern<A>
    | TuplePattern<A>
    | UnitPattern<A>
    | WildcardPattern<A>;

  export function decodePattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): Pattern<A> {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "AsPattern":
        return decodeAsPattern(decodeA, input);
      case "ConstructorPattern":
        return decodeConstructorPattern(decodeA, input);
      case "EmptyListPattern":
        return decodeEmptyListPattern(decodeA, input);
      case "HeadTailPattern":
        return decodeHeadTailPattern(decodeA, input);
      case "LiteralPattern":
        return decodeLiteralPattern(decodeA, input);
      case "TuplePattern":
        return decodeTuplePattern(decodeA, input);
      case "UnitPattern":
        return decodeUnitPattern(decodeA, input);
      case "WildcardPattern":
        return decodeWildcardPattern(decodeA, input);
    }
    codecs.raiseDecodeErrorFromCustomType("Pattern", kind);
  }

  export function encodePattern<A>(
    encodeA: (value: A) => any,
    value: Pattern<A>
  ): any {
    switch (value.kind) {
      case "AsPattern":
        return encodeAsPattern(encodeA, value);
      case "ConstructorPattern":
        return encodeConstructorPattern(encodeA, value);
      case "EmptyListPattern":
        return encodeEmptyListPattern(encodeA, value);
      case "HeadTailPattern":
        return encodeHeadTailPattern(encodeA, value);
      case "LiteralPattern":
        return encodeLiteralPattern(encodeA, value);
      case "TuplePattern":
        return encodeTuplePattern(encodeA, value);
      case "UnitPattern":
        return encodeUnitPattern(encodeA, value);
      case "WildcardPattern":
        return encodeWildcardPattern(encodeA, value);
    }
  }

  export class AsPattern<A> {
    kind: "AsPattern" = "AsPattern";

    constructor(
      public arg1: A,
      public arg2: Morphir_IR_Value.Pattern<A>,
      public arg3: Morphir_IR_Name.Name
    ) {}
  }

  export function decodeAsPattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): AsPattern<A> {
    codecs.preprocessCustomTypeVariant("AsPattern", 3, input);
    return new AsPattern(
      decodeA(input[1]),
      Morphir_IR_Value.decodePattern(decodeA, input[2]),
      Morphir_IR_Name.decodeName(input[3])
    );
  }

  export function encodeAsPattern<A>(
    encodeA: (value: A) => any,
    value: AsPattern<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_Value.encodePattern(encodeA, value.arg2),
      Morphir_IR_Name.encodeName(value.arg3),
    ];
  }

  export class ConstructorPattern<A> {
    kind: "ConstructorPattern" = "ConstructorPattern";

    constructor(
      public arg1: A,
      public arg2: Morphir_IR_FQName.FQName,
      public arg3: Array<Morphir_IR_Value.Pattern<A>>
    ) {}
  }

  export function decodeConstructorPattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): ConstructorPattern<A> {
    codecs.preprocessCustomTypeVariant("ConstructorPattern", 3, input);
    return new ConstructorPattern(
      decodeA(input[1]),
      Morphir_IR_FQName.decodeFQName(input[2]),
      codecs.decodeList(
        Morphir_IR_Value.decodePattern.bind(null, decodeA),
        input[3]
      )
    );
  }

  export function encodeConstructorPattern<A>(
    encodeA: (value: A) => any,
    value: ConstructorPattern<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_FQName.encodeFQName(value.arg2),
      codecs.encodeList(
        Morphir_IR_Value.encodePattern.bind(null, encodeA),
        value.arg3
      ),
    ];
  }

  export class EmptyListPattern<A> {
    kind: "EmptyListPattern" = "EmptyListPattern";

    constructor(public arg1: A) {}
  }

  export function decodeEmptyListPattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): EmptyListPattern<A> {
    codecs.preprocessCustomTypeVariant("EmptyListPattern", 1, input);
    return new EmptyListPattern(decodeA(input[1]));
  }

  export function encodeEmptyListPattern<A>(
    encodeA: (value: A) => any,
    value: EmptyListPattern<A>
  ): any {
    return [value.kind, encodeA(value.arg1)];
  }

  export class HeadTailPattern<A> {
    kind: "HeadTailPattern" = "HeadTailPattern";

    constructor(
      public arg1: A,
      public arg2: Morphir_IR_Value.Pattern<A>,
      public arg3: Morphir_IR_Value.Pattern<A>
    ) {}
  }

  export function decodeHeadTailPattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): HeadTailPattern<A> {
    codecs.preprocessCustomTypeVariant("HeadTailPattern", 3, input);
    return new HeadTailPattern(
      decodeA(input[1]),
      Morphir_IR_Value.decodePattern(decodeA, input[2]),
      Morphir_IR_Value.decodePattern(decodeA, input[3])
    );
  }

  export function encodeHeadTailPattern<A>(
    encodeA: (value: A) => any,
    value: HeadTailPattern<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_Value.encodePattern(encodeA, value.arg2),
      Morphir_IR_Value.encodePattern(encodeA, value.arg3),
    ];
  }

  export class LiteralPattern<A> {
    kind: "LiteralPattern" = "LiteralPattern";

    constructor(public arg1: A, public arg2: Morphir_IR_Literal.Literal) {}
  }

  export function decodeLiteralPattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): LiteralPattern<A> {
    codecs.preprocessCustomTypeVariant("LiteralPattern", 2, input);
    return new LiteralPattern(
      decodeA(input[1]),
      Morphir_IR_Literal.decodeLiteral(input[2])
    );
  }

  export function encodeLiteralPattern<A>(
    encodeA: (value: A) => any,
    value: LiteralPattern<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      Morphir_IR_Literal.encodeLiteral(value.arg2),
    ];
  }

  export class TuplePattern<A> {
    kind: "TuplePattern" = "TuplePattern";

    constructor(
      public arg1: A,
      public arg2: Array<Morphir_IR_Value.Pattern<A>>
    ) {}
  }

  export function decodeTuplePattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): TuplePattern<A> {
    codecs.preprocessCustomTypeVariant("TuplePattern", 2, input);
    return new TuplePattern(
      decodeA(input[1]),
      codecs.decodeList(
        Morphir_IR_Value.decodePattern.bind(null, decodeA),
        input[2]
      )
    );
  }

  export function encodeTuplePattern<A>(
    encodeA: (value: A) => any,
    value: TuplePattern<A>
  ): any {
    return [
      value.kind,
      encodeA(value.arg1),
      codecs.encodeList(
        Morphir_IR_Value.encodePattern.bind(null, encodeA),
        value.arg2
      ),
    ];
  }

  export class UnitPattern<A> {
    kind: "UnitPattern" = "UnitPattern";

    constructor(public arg1: A) {}
  }

  export function decodeUnitPattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): UnitPattern<A> {
    codecs.preprocessCustomTypeVariant("UnitPattern", 1, input);
    return new UnitPattern(decodeA(input[1]));
  }

  export function encodeUnitPattern<A>(
    encodeA: (value: A) => any,
    value: UnitPattern<A>
  ): any {
    return [value.kind, encodeA(value.arg1)];
  }

  export class WildcardPattern<A> {
    kind: "WildcardPattern" = "WildcardPattern";

    constructor(public arg1: A) {}
  }

  export function decodeWildcardPattern<A>(
    decodeA: (input: any) => A,
    input: any
  ): WildcardPattern<A> {
    codecs.preprocessCustomTypeVariant("WildcardPattern", 1, input);
    return new WildcardPattern(decodeA(input[1]));
  }

  export function encodeWildcardPattern<A>(
    encodeA: (value: A) => any,
    value: WildcardPattern<A>
  ): any {
    return [value.kind, encodeA(value.arg1)];
  }

  /* A value without any additional information.
   */
  export type RawValue = Morphir_IR_Value.Value<[], []>;

  export function decodeRawValue(input: any): RawValue {
    return Morphir_IR_Value.decodeValue(
      codecs.decodeUnit,
      codecs.decodeUnit,
      input
    );
  }

  export function encodeRawValue(value: RawValue): any {
    return Morphir_IR_Value.encodeValue(
      codecs.encodeUnit,
      codecs.encodeUnit,
      value
    );
  }

  /* Type that represents a value or function specification. The specification of what the value or function
  is without the actual data or logic behind it.
  */
  export type Specification<Ta> = {
    inputs: Array<[Morphir_IR_Name.Name, Morphir_IR_Type.Type<Ta>]>;
    output: Morphir_IR_Type.Type<Ta>;
  };

  export function decodeSpecification<Ta>(
    decodeTa: (input: any) => Ta,
    input: any
  ): Specification<Ta> {
    return codecs.decodeRecord(
      codecs.buildCodecMap([
        [
          "inputs",
          codecs.decodeList.bind(
            null,
            codecs.decodeTuple.bind(null, [
              Morphir_IR_Name.decodeName,
              Morphir_IR_Type.decodeType.bind(null, decodeTa),
            ])
          ),
        ],
        ["output", Morphir_IR_Type.decodeType.bind(null, decodeTa)],
      ]),
      input
    );
  }

  export function encodeSpecification<Ta>(
    encodeTa: (value: Ta) => any,
    value: Specification<Ta>
  ): any {
    return codecs.encodeRecord(
      codecs.buildCodecMap([
        [
          "inputs",
          codecs.encodeList.bind(
            null,
            codecs.encodeTuple.bind(null, [
              Morphir_IR_Name.encodeName,
              Morphir_IR_Type.encodeType.bind(null, encodeTa),
            ])
          ),
        ],
        ["output", Morphir_IR_Type.encodeType.bind(null, encodeTa)],
      ]),
      value
    );
  }

  /* A value with type information.
   */
  export type TypedValue = Morphir_IR_Value.Value<[], Morphir_IR_Type.Type<[]>>;

  export function decodeTypedValue(input: any): TypedValue {
    return Morphir_IR_Value.decodeValue(
      codecs.decodeUnit,
      Morphir_IR_Type.decodeType.bind(null, codecs.decodeUnit),
      input
    );
  }

  export function encodeTypedValue(value: TypedValue): any {
    return Morphir_IR_Value.encodeValue(
      codecs.encodeUnit,
      Morphir_IR_Type.encodeType.bind(null, codecs.encodeUnit),
      value
    );
  }

  /* Type that represents a value expression. This is a recursive data structure with various node types representing
  each possible language construct.
  
  The extra type parameters `ta` and `va` allow you to add type and value attributes. Type attributes allow you to add
  extra information to each type node. Value attributes do the same for value nodes. In many cases you might not need this
  in which case you can just put a unit (`()`) type or a type variable as a placeholder.
  
  These are the supported node types:
  
    - **Literal**
        - Represents a literal value like 13, True or "foo".
        - See the documentation in the [Literal](Morphir-IR-Literal) module for details on the supported literal types.
        - See [Wikipedia: Literal](https://en.wikipedia.org/wiki/Literal_(computer_programming)) for more details on
          literals.
    - **Constructor**
        - Reference to a custom type constructor name.
        - If the type constructor has arguments this node will be wrapped into some `Apply` nodes depending on the number
          of arguments.
    - **Tuple**
        - Represents a tuple value.
        - Each element of the tuple is in turn a `Value`.
    - **List**
        - Represents a list of values.
        - Each item of the list is in turn a `Value`.
    - **Record**
        - Represents a record value.
        - Each field value of the record is in turn a `Value`.
    - **Variable**
        - Reference to a variable.
    - **Reference**
        - Reference to another value within or outside the module.
        - References are always full-qualified to make resolution easier.
    - **Field**
        - Represents accessing a field on a record together with the target expression.
        - This is done using the dot notation in Elm: `foo.bar`
    - **FieldFunction**
        - Represents accessing a field on a record without the target expression.
        - This is a shortcut to refer to the function that extracts the field from the input.
        - This is done using the dot notation in Elm without a target expression: `.bar`
    - **Apply**
        - Represents a function application.
        - The two arguments are the target function and the argument.
        - Multi-argument invocations are expressed by wrapping multiple `Apply` nodes in each other (currying).
    - **Lambda**
        - Represents a lambda abstraction.
        - The first argument is a pattern to match on the input, the second is the lambda expression's body.
    - **LetDefinition**
        - Represents a single let binding.
        - Multiple let bindings are achieved through wrapping multiple let expressions into each other.
    - **LetRecursion**
        - Special let binding that allows mutual recursion between the bindings.
        - This is necessary because `LetDefinition` will not make recursion possible due to its scoping rules.
    - **Destructure**
        - Applies a pattern match to the first expression and passes any extracted variables to the second expression.
        - This can be represented as a let expression with a pattern binding or a single-case pattern-match in Elm.
    - **IfThenElse**
        - Represents a simple if/then/else expression.
        - The 3 arguments are: the condition, the then branch and the else branch.
    - **PatternMatch**
        - Represents a pattern-match.
    - **UpdateRecord**
        - Expression to update one or more fields of a record.
        - As usual in FP this is a copy-on-update so no mutation is happening.
    - **Unit**
        - Represents the single value in the Unit type.
        - When you find Unit in the IR it usually means: "There's nothing useful here".
  
  */
  export type Value<Ta, Va> =
    | Apply<Va, Ta>
    | Constructor<Va>
    | Destructure<Va, Ta>
    | Field<Va, Ta>
    | FieldFunction<Va>
    | IfThenElse<Va, Ta>
    | Lambda<Va, Ta>
    | LetDefinition<Va, Ta>
    | LetRecursion<Va, Ta>
    | List<Va, Ta>
    | Literal<Va>
    | PatternMatch<Va, Ta>
    | Record<Va, Ta>
    | Reference<Va>
    | Tuple<Va, Ta>
    | Unit<Va>
    | UpdateRecord<Va, Ta>
    | Variable<Va>;

  export function decodeValue<Ta, Va>(
    decodeTa: (input: any) => Ta,
    decodeVa: (input: any) => Va,
    input: any
  ): Value<Ta, Va> {
    let kind = codecs.parseKindFromCustomTypeInput(input);
    switch (kind) {
      case "Apply":
        return decodeApply(decodeVa, decodeTa, input);
      case "Constructor":
        return decodeConstructor(decodeVa, input);
      case "Destructure":
        return decodeDestructure(decodeVa, decodeTa, input);
      case "Field":
        return decodeField(decodeVa, decodeTa, input);
      case "FieldFunction":
        return decodeFieldFunction(decodeVa, input);
      case "IfThenElse":
        return decodeIfThenElse(decodeVa, decodeTa, input);
      case "Lambda":
        return decodeLambda(decodeVa, decodeTa, input);
      case "LetDefinition":
        return decodeLetDefinition(decodeVa, decodeTa, input);
      case "LetRecursion":
        return decodeLetRecursion(decodeVa, decodeTa, input);
      case "List":
        return decodeList(decodeVa, decodeTa, input);
      case "Literal":
        return decodeLiteral(decodeVa, input);
      case "PatternMatch":
        return decodePatternMatch(decodeVa, decodeTa, input);
      case "Record":
        return decodeRecord(decodeVa, decodeTa, input);
      case "Reference":
        return decodeReference(decodeVa, input);
      case "Tuple":
        return decodeTuple(decodeVa, decodeTa, input);
      case "Unit":
        return decodeUnit(decodeVa, input);
      case "UpdateRecord":
        return decodeUpdateRecord(decodeVa, decodeTa, input);
      case "Variable":
        return decodeVariable(decodeVa, input);
    }
    codecs.raiseDecodeErrorFromCustomType("Value", kind);
  }

  export function encodeValue<Ta, Va>(
    encodeTa: (value: Ta) => any,
    encodeVa: (value: Va) => any,
    value: Value<Ta, Va>
  ): any {
    switch (value.kind) {
      case "Apply":
        return encodeApply(encodeVa, encodeTa, value);
      case "Constructor":
        return encodeConstructor(encodeVa, value);
      case "Destructure":
        return encodeDestructure(encodeVa, encodeTa, value);
      case "Field":
        return encodeField(encodeVa, encodeTa, value);
      case "FieldFunction":
        return encodeFieldFunction(encodeVa, value);
      case "IfThenElse":
        return encodeIfThenElse(encodeVa, encodeTa, value);
      case "Lambda":
        return encodeLambda(encodeVa, encodeTa, value);
      case "LetDefinition":
        return encodeLetDefinition(encodeVa, encodeTa, value);
      case "LetRecursion":
        return encodeLetRecursion(encodeVa, encodeTa, value);
      case "List":
        return encodeList(encodeVa, encodeTa, value);
      case "Literal":
        return encodeLiteral(encodeVa, value);
      case "PatternMatch":
        return encodePatternMatch(encodeVa, encodeTa, value);
      case "Record":
        return encodeRecord(encodeVa, encodeTa, value);
      case "Reference":
        return encodeReference(encodeVa, value);
      case "Tuple":
        return encodeTuple(encodeVa, encodeTa, value);
      case "Unit":
        return encodeUnit(encodeVa, value);
      case "UpdateRecord":
        return encodeUpdateRecord(encodeVa, encodeTa, value);
      case "Variable":
        return encodeVariable(encodeVa, value);
    }
  }

  export class Apply<Va, Ta> {
    kind: "Apply" = "Apply";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Value.Value<Ta, Va>,
      public arg3: Morphir_IR_Value.Value<Ta, Va>
    ) {}
  }

  export function decodeApply<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): Apply<Va, Ta> {
    codecs.preprocessCustomTypeVariant("Apply", 3, input);
    return new Apply(
      decodeVa(input[1]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[2]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[3])
    );
  }

  export function encodeApply<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: Apply<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg2),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg3),
    ];
  }

  export class Constructor<Va> {
    kind: "Constructor" = "Constructor";

    constructor(public arg1: Va, public arg2: Morphir_IR_FQName.FQName) {}
  }

  export function decodeConstructor<Va>(
    decodeVa: (input: any) => Va,
    input: any
  ): Constructor<Va> {
    codecs.preprocessCustomTypeVariant("Constructor", 2, input);
    return new Constructor(
      decodeVa(input[1]),
      Morphir_IR_FQName.decodeFQName(input[2])
    );
  }

  export function encodeConstructor<Va>(
    encodeVa: (value: Va) => any,
    value: Constructor<Va>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_FQName.encodeFQName(value.arg2),
    ];
  }

  export class Destructure<Va, Ta> {
    kind: "Destructure" = "Destructure";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Value.Pattern<Va>,
      public arg3: Morphir_IR_Value.Value<Ta, Va>,
      public arg4: Morphir_IR_Value.Value<Ta, Va>
    ) {}
  }

  export function decodeDestructure<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): Destructure<Va, Ta> {
    codecs.preprocessCustomTypeVariant("Destructure", 4, input);
    return new Destructure(
      decodeVa(input[1]),
      Morphir_IR_Value.decodePattern(decodeVa, input[2]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[3]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[4])
    );
  }

  export function encodeDestructure<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: Destructure<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Value.encodePattern(encodeVa, value.arg2),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg3),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg4),
    ];
  }

  export class Field<Va, Ta> {
    kind: "Field" = "Field";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Value.Value<Ta, Va>,
      public arg3: Morphir_IR_Name.Name
    ) {}
  }

  export function decodeField<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): Field<Va, Ta> {
    codecs.preprocessCustomTypeVariant("Field", 3, input);
    return new Field(
      decodeVa(input[1]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[2]),
      Morphir_IR_Name.decodeName(input[3])
    );
  }

  export function encodeField<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: Field<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg2),
      Morphir_IR_Name.encodeName(value.arg3),
    ];
  }

  export class FieldFunction<Va> {
    kind: "FieldFunction" = "FieldFunction";

    constructor(public arg1: Va, public arg2: Morphir_IR_Name.Name) {}
  }

  export function decodeFieldFunction<Va>(
    decodeVa: (input: any) => Va,
    input: any
  ): FieldFunction<Va> {
    codecs.preprocessCustomTypeVariant("FieldFunction", 2, input);
    return new FieldFunction(
      decodeVa(input[1]),
      Morphir_IR_Name.decodeName(input[2])
    );
  }

  export function encodeFieldFunction<Va>(
    encodeVa: (value: Va) => any,
    value: FieldFunction<Va>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Name.encodeName(value.arg2),
    ];
  }

  export class IfThenElse<Va, Ta> {
    kind: "IfThenElse" = "IfThenElse";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Value.Value<Ta, Va>,
      public arg3: Morphir_IR_Value.Value<Ta, Va>,
      public arg4: Morphir_IR_Value.Value<Ta, Va>
    ) {}
  }

  export function decodeIfThenElse<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): IfThenElse<Va, Ta> {
    codecs.preprocessCustomTypeVariant("IfThenElse", 4, input);
    return new IfThenElse(
      decodeVa(input[1]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[2]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[3]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[4])
    );
  }

  export function encodeIfThenElse<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: IfThenElse<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg2),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg3),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg4),
    ];
  }

  export class Lambda<Va, Ta> {
    kind: "Lambda" = "Lambda";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Value.Pattern<Va>,
      public arg3: Morphir_IR_Value.Value<Ta, Va>
    ) {}
  }

  export function decodeLambda<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): Lambda<Va, Ta> {
    codecs.preprocessCustomTypeVariant("Lambda", 3, input);
    return new Lambda(
      decodeVa(input[1]),
      Morphir_IR_Value.decodePattern(decodeVa, input[2]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[3])
    );
  }

  export function encodeLambda<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: Lambda<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Value.encodePattern(encodeVa, value.arg2),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg3),
    ];
  }

  export class LetDefinition<Va, Ta> {
    kind: "LetDefinition" = "LetDefinition";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Name.Name,
      public arg3: Morphir_IR_Value.Definition<Ta, Va>,
      public arg4: Morphir_IR_Value.Value<Ta, Va>
    ) {}
  }

  export function decodeLetDefinition<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): LetDefinition<Va, Ta> {
    codecs.preprocessCustomTypeVariant("LetDefinition", 4, input);
    return new LetDefinition(
      decodeVa(input[1]),
      Morphir_IR_Name.decodeName(input[2]),
      Morphir_IR_Value.decodeDefinition(decodeTa, decodeVa, input[3]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[4])
    );
  }

  export function encodeLetDefinition<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: LetDefinition<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Name.encodeName(value.arg2),
      Morphir_IR_Value.encodeDefinition(encodeTa, encodeVa, value.arg3),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg4),
    ];
  }

  export class LetRecursion<Va, Ta> {
    kind: "LetRecursion" = "LetRecursion";

    constructor(
      public arg1: Va,
      public arg2: Map<
        Morphir_IR_Name.Name,
        Morphir_IR_Value.Definition<Ta, Va>
      >,
      public arg3: Morphir_IR_Value.Value<Ta, Va>
    ) {}
  }

  export function decodeLetRecursion<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): LetRecursion<Va, Ta> {
    codecs.preprocessCustomTypeVariant("LetRecursion", 3, input);
    return new LetRecursion(
      decodeVa(input[1]),
      codecs.decodeDict(
        Morphir_IR_Name.decodeName,
        Morphir_IR_Value.decodeDefinition.bind(null, decodeTa, decodeVa),
        input[2]
      ),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[3])
    );
  }

  export function encodeLetRecursion<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: LetRecursion<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      codecs.encodeDict(
        Morphir_IR_Name.encodeName,
        Morphir_IR_Value.encodeDefinition.bind(null, encodeTa, encodeVa),
        value.arg2
      ),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg3),
    ];
  }

  export class List<Va, Ta> {
    kind: "List" = "List";

    constructor(
      public arg1: Va,
      public arg2: Array<Morphir_IR_Value.Value<Ta, Va>>
    ) {}
  }

  export function decodeList<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): List<Va, Ta> {
    codecs.preprocessCustomTypeVariant("List", 2, input);
    return new List(
      decodeVa(input[1]),
      codecs.decodeList(
        Morphir_IR_Value.decodeValue.bind(null, decodeTa, decodeVa),
        input[2]
      )
    );
  }

  export function encodeList<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: List<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      codecs.encodeList(
        Morphir_IR_Value.encodeValue.bind(null, encodeTa, encodeVa),
        value.arg2
      ),
    ];
  }

  export class Literal<Va> {
    kind: "Literal" = "Literal";

    constructor(public arg1: Va, public arg2: Morphir_IR_Literal.Literal) {}
  }

  export function decodeLiteral<Va>(
    decodeVa: (input: any) => Va,
    input: any
  ): Literal<Va> {
    codecs.preprocessCustomTypeVariant("Literal", 2, input);
    return new Literal(
      decodeVa(input[1]),
      Morphir_IR_Literal.decodeLiteral(input[2])
    );
  }

  export function encodeLiteral<Va>(
    encodeVa: (value: Va) => any,
    value: Literal<Va>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Literal.encodeLiteral(value.arg2),
    ];
  }

  export class PatternMatch<Va, Ta> {
    kind: "PatternMatch" = "PatternMatch";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Value.Value<Ta, Va>,
      public arg3: Array<
        [Morphir_IR_Value.Pattern<Va>, Morphir_IR_Value.Value<Ta, Va>]
      >
    ) {}
  }

  export function decodePatternMatch<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): PatternMatch<Va, Ta> {
    codecs.preprocessCustomTypeVariant("PatternMatch", 3, input);
    return new PatternMatch(
      decodeVa(input[1]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[2]),
      codecs.decodeList(
        codecs.decodeTuple.bind(null, [
          Morphir_IR_Value.decodePattern.bind(null, decodeVa),
          Morphir_IR_Value.decodeValue.bind(null, decodeTa, decodeVa),
        ]),
        input[3]
      )
    );
  }

  export function encodePatternMatch<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: PatternMatch<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg2),
      codecs.encodeList(
        codecs.encodeTuple.bind(null, [
          Morphir_IR_Value.encodePattern.bind(null, encodeVa),
          Morphir_IR_Value.encodeValue.bind(null, encodeTa, encodeVa),
        ]),
        value.arg3
      ),
    ];
  }

  export class Record<Va, Ta> {
    kind: "Record" = "Record";

    constructor(
      public arg1: Va,
      public arg2: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Value<Ta, Va>]>
    ) {}
  }

  export function decodeRecord<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): Record<Va, Ta> {
    codecs.preprocessCustomTypeVariant("Record", 2, input);
    return new Record(
      decodeVa(input[1]),
      codecs.decodeList(
        codecs.decodeTuple.bind(null, [
          Morphir_IR_Name.decodeName,
          Morphir_IR_Value.decodeValue.bind(null, decodeTa, decodeVa),
        ]),
        input[2]
      )
    );
  }

  export function encodeRecord<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: Record<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      codecs.encodeList(
        codecs.encodeTuple.bind(null, [
          Morphir_IR_Name.encodeName,
          Morphir_IR_Value.encodeValue.bind(null, encodeTa, encodeVa),
        ]),
        value.arg2
      ),
    ];
  }

  export class Reference<Va> {
    kind: "Reference" = "Reference";

    constructor(public arg1: Va, public arg2: Morphir_IR_FQName.FQName) {}
  }

  export function decodeReference<Va>(
    decodeVa: (input: any) => Va,
    input: any
  ): Reference<Va> {
    codecs.preprocessCustomTypeVariant("Reference", 2, input);
    return new Reference(
      decodeVa(input[1]),
      Morphir_IR_FQName.decodeFQName(input[2])
    );
  }

  export function encodeReference<Va>(
    encodeVa: (value: Va) => any,
    value: Reference<Va>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_FQName.encodeFQName(value.arg2),
    ];
  }

  export class Tuple<Va, Ta> {
    kind: "Tuple" = "Tuple";

    constructor(
      public arg1: Va,
      public arg2: Array<Morphir_IR_Value.Value<Ta, Va>>
    ) {}
  }

  export function decodeTuple<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): Tuple<Va, Ta> {
    codecs.preprocessCustomTypeVariant("Tuple", 2, input);
    return new Tuple(
      decodeVa(input[1]),
      codecs.decodeList(
        Morphir_IR_Value.decodeValue.bind(null, decodeTa, decodeVa),
        input[2]
      )
    );
  }

  export function encodeTuple<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: Tuple<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      codecs.encodeList(
        Morphir_IR_Value.encodeValue.bind(null, encodeTa, encodeVa),
        value.arg2
      ),
    ];
  }

  export class Unit<Va> {
    kind: "Unit" = "Unit";

    constructor(public arg1: Va) {}
  }

  export function decodeUnit<Va>(
    decodeVa: (input: any) => Va,
    input: any
  ): Unit<Va> {
    codecs.preprocessCustomTypeVariant("Unit", 1, input);
    return new Unit(decodeVa(input[1]));
  }

  export function encodeUnit<Va>(
    encodeVa: (value: Va) => any,
    value: Unit<Va>
  ): any {
    return [value.kind, encodeVa(value.arg1)];
  }

  export class UpdateRecord<Va, Ta> {
    kind: "UpdateRecord" = "UpdateRecord";

    constructor(
      public arg1: Va,
      public arg2: Morphir_IR_Value.Value<Ta, Va>,
      public arg3: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Value<Ta, Va>]>
    ) {}
  }

  export function decodeUpdateRecord<Va, Ta>(
    decodeVa: (input: any) => Va,
    decodeTa: (input: any) => Ta,
    input: any
  ): UpdateRecord<Va, Ta> {
    codecs.preprocessCustomTypeVariant("UpdateRecord", 3, input);
    return new UpdateRecord(
      decodeVa(input[1]),
      Morphir_IR_Value.decodeValue(decodeTa, decodeVa, input[2]),
      codecs.decodeList(
        codecs.decodeTuple.bind(null, [
          Morphir_IR_Name.decodeName,
          Morphir_IR_Value.decodeValue.bind(null, decodeTa, decodeVa),
        ]),
        input[3]
      )
    );
  }

  export function encodeUpdateRecord<Va, Ta>(
    encodeVa: (value: Va) => any,
    encodeTa: (value: Ta) => any,
    value: UpdateRecord<Va, Ta>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Value.encodeValue(encodeTa, encodeVa, value.arg2),
      codecs.encodeList(
        codecs.encodeTuple.bind(null, [
          Morphir_IR_Name.encodeName,
          Morphir_IR_Value.encodeValue.bind(null, encodeTa, encodeVa),
        ]),
        value.arg3
      ),
    ];
  }

  export class Variable<Va> {
    kind: "Variable" = "Variable";

    constructor(public arg1: Va, public arg2: Morphir_IR_Name.Name) {}
  }

  export function decodeVariable<Va>(
    decodeVa: (input: any) => Va,
    input: any
  ): Variable<Va> {
    codecs.preprocessCustomTypeVariant("Variable", 2, input);
    return new Variable(
      decodeVa(input[1]),
      Morphir_IR_Name.decodeName(input[2])
    );
  }

  export function encodeVariable<Va>(
    encodeVa: (value: Va) => any,
    value: Variable<Va>
  ): any {
    return [
      value.kind,
      encodeVa(value.arg1),
      Morphir_IR_Name.encodeName(value.arg2),
    ];
  }
}
