// Generated by morphir-elm

import * as codecs from "./../../morphir/internal/Codecs"
import { Morphir_IR_FQName } from "./../../morphir/ir/FQName"
import { Morphir_IR_Literal } from "./../../morphir/ir/Literal"
import { Morphir_IR_Name } from "./../../morphir/ir/Name"
import { Morphir_IR_Type } from "./../../morphir/ir/Type"

export namespace Morphir_IR_Value {
  /* Type that represents a value or function definition. A definition is the actual data or logic as opposed to a specification
  which is just the specification of those. Value definitions can be typed or untyped. Exposed values have to be typed.
  */
  export type Definition<ta, va> = {
    inputTypes: Array<[Morphir_IR_Name.Name, va, Morphir_IR_Type.Type<ta>]>;
    outputType: Morphir_IR_Type.Type<ta>;
    body: Morphir_IR_Value.Value<ta, va>;
  }
  
  export function decodeDefinition(varDecoders, input) {
  return codecs.decodeRecord(new Map([["inputTypes", codecs.decodeList.bind(null, codecs.decodeTuple.bind(null, [Morphir_IR_Name.decodeName.bind(null, varDecoders), varDecoders.Va.bind(null), Morphir_IR_Type.decodeType.bind(null, varDecoders)]))], ["outputType", Morphir_IR_Type.decodeType.bind(null, varDecoders)], ["body", Morphir_IR_Value.decodeValue.bind(null, varDecoders)]]), input);
  }
  
  export function encodeDefinition(varEncoders, value) {
  return codecs.encodeRecord(new Map([["inputTypes", codecs.encodeList.bind(null, codecs.encodeTuple.bind(null, [codecs.encodeUnit.bind(null), varEncoders.va.bind(null), codecs.encodeUnit.bind(null)]))], ["outputType", codecs.encodeUnit.bind(null)], ["body", codecs.encodeUnit.bind(null)]]), value);
  }
  
  /* Type that represents a pattern. A pattern can do two things: match on a specific shape or exact value and extract
  parts of a value into variables. It's a recursive data structure made of of the following building blocks:
  
    - **WildcardPattern**
        - Matches any value and does not extract any variables.
        - `_` in Elm
    - **AsPattern**
        - Assigns a variable name to the value matched by a nested pattern.
        - `(...) as foo` in Elm
        - Special case: when there is just a variable name in a pattern in Elm it will be represented as a
          `WildcardPattern` wrapped in an `AsPattern`
    - **TuplePattern**
        - Matches on a tuple where each element matches the nested patterns.
    - **ConstructorPattern**
        - Matches on a type constructor and its arguments.
    - **EmptyListPattern**
        - Matches on an empty list.
    - **HeadTailPattern**
        - Matches on the head and the tail of a list.
        - Combined with `EmptyListPattern` it can match on lists of any specific sizes.
    - **LiteralPattern**
        - Matches an an exact literal value.
    - **UnitPattern**
        - Matches the `Unit` value only.
  
  */
  export type Pattern<a> = AsPattern<a> | ConstructorPattern<a> | EmptyListPattern<a> | HeadTailPattern<a> | LiteralPattern<a> | TuplePattern<a> | UnitPattern<a> | WildcardPattern<a>
  
  export function decodePattern(varDecoders, input) {
  let decoderMap = new Map();
  decoderMap.set("AsPattern", decodeAsPattern.bind(varDecoders));
  decoderMap.set("ConstructorPattern", decodeConstructorPattern.bind(varDecoders));
  decoderMap.set("EmptyListPattern", decodeEmptyListPattern.bind(varDecoders));
  decoderMap.set("HeadTailPattern", decodeHeadTailPattern.bind(varDecoders));
  decoderMap.set("LiteralPattern", decodeLiteralPattern.bind(varDecoders));
  decoderMap.set("TuplePattern", decodeTuplePattern.bind(varDecoders));
  decoderMap.set("UnitPattern", decodeUnitPattern.bind(varDecoders));
  decoderMap.set("WildcardPattern", decodeWildcardPattern.bind(varDecoders));
  codecs.decodeCustomType(decoderMap, input);
  }
  
  
  
  export interface AsPattern<a> {
    kind: "AsPattern";
    arg1: a;
    arg2: Morphir_IR_Value.Pattern<a>;
    arg3: Morphir_IR_Name.Name;
  }
  
  export function decodeAsPattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("AsPattern", ["Arg1", "Arg2", "Arg3"], [varDecoders.A.bind(null), Morphir_IR_Value.decodePattern.bind(null, varDecoders), Morphir_IR_Name.decodeName.bind(null, varDecoders)], input);
  }
  
  export interface ConstructorPattern<a> {
    kind: "ConstructorPattern";
    arg1: a;
    arg2: Morphir_IR_FQName.FQName;
    arg3: Array<Morphir_IR_Value.Pattern<a>>;
  }
  
  export function decodeConstructorPattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("ConstructorPattern", ["Arg1", "Arg2", "Arg3"], [varDecoders.A.bind(null), Morphir_IR_FQName.decodeFQName.bind(null, varDecoders), codecs.decodeList.bind(null, Morphir_IR_Value.decodePattern.bind(null, varDecoders))], input);
  }
  
  export interface EmptyListPattern<a> {
    kind: "EmptyListPattern";
    arg1: a;
  }
  
  export function decodeEmptyListPattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("EmptyListPattern", ["Arg1"], [varDecoders.A.bind(null)], input);
  }
  
  export interface HeadTailPattern<a> {
    kind: "HeadTailPattern";
    arg1: a;
    arg2: Morphir_IR_Value.Pattern<a>;
    arg3: Morphir_IR_Value.Pattern<a>;
  }
  
  export function decodeHeadTailPattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("HeadTailPattern", ["Arg1", "Arg2", "Arg3"], [varDecoders.A.bind(null), Morphir_IR_Value.decodePattern.bind(null, varDecoders), Morphir_IR_Value.decodePattern.bind(null, varDecoders)], input);
  }
  
  export interface LiteralPattern<a> {
    kind: "LiteralPattern";
    arg1: a;
    arg2: Morphir_IR_Literal.Literal;
  }
  
  export function decodeLiteralPattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("LiteralPattern", ["Arg1", "Arg2"], [varDecoders.A.bind(null), Morphir_IR_Literal.decodeLiteral.bind(null, varDecoders)], input);
  }
  
  export interface TuplePattern<a> {
    kind: "TuplePattern";
    arg1: a;
    arg2: Array<Morphir_IR_Value.Pattern<a>>;
  }
  
  export function decodeTuplePattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("TuplePattern", ["Arg1", "Arg2"], [varDecoders.A.bind(null), codecs.decodeList.bind(null, Morphir_IR_Value.decodePattern.bind(null, varDecoders))], input);
  }
  
  export interface UnitPattern<a> {
    kind: "UnitPattern";
    arg1: a;
  }
  
  export function decodeUnitPattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("UnitPattern", ["Arg1"], [varDecoders.A.bind(null)], input);
  }
  
  export interface WildcardPattern<a> {
    kind: "WildcardPattern";
    arg1: a;
  }
  
  export function decodeWildcardPattern(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("WildcardPattern", ["Arg1"], [varDecoders.A.bind(null)], input);
  }
  
  /* A value without any additional information.
  */
  export type RawValue = Morphir_IR_Value.Value<[], []>
  
  export function decodeRawValue(varDecoders, input) {
  return Morphir_IR_Value.decodeValue(varDecoders, input);
  }
  
  export function encodeRawValue(varEncoders, value) {
  return codecs.encodeUnit(value);
  }
  
  /* Type that represents a value or function specification. The specification of what the value or function
  is without the actual data or logic behind it.
  */
  export type Specification<ta> = {
    inputs: Array<[Morphir_IR_Name.Name, Morphir_IR_Type.Type<ta>]>;
    output: Morphir_IR_Type.Type<ta>;
  }
  
  export function decodeSpecification(varDecoders, input) {
  return codecs.decodeRecord(new Map([["inputs", codecs.decodeList.bind(null, codecs.decodeTuple.bind(null, [Morphir_IR_Name.decodeName.bind(null, varDecoders), Morphir_IR_Type.decodeType.bind(null, varDecoders)]))], ["output", Morphir_IR_Type.decodeType.bind(null, varDecoders)]]), input);
  }
  
  export function encodeSpecification(varEncoders, value) {
  return codecs.encodeRecord(new Map([["inputs", codecs.encodeList.bind(null, codecs.encodeTuple.bind(null, [codecs.encodeUnit.bind(null), codecs.encodeUnit.bind(null)]))], ["output", codecs.encodeUnit.bind(null)]]), value);
  }
  
  /* A value with type information.
  */
  export type TypedValue = Morphir_IR_Value.Value<[], Morphir_IR_Type.Type<[]>>
  
  export function decodeTypedValue(varDecoders, input) {
  return Morphir_IR_Value.decodeValue(varDecoders, input);
  }
  
  export function encodeTypedValue(varEncoders, value) {
  return codecs.encodeUnit(value);
  }
  
  /* Type that represents a value expression. This is a recursive data structure with various node types representing
  each possible language construct.
  
  The extra type parameters `ta` and `va` allow you to add type and value attributes. Type attributes allow you to add
  extra information to each type node. Value attributes do the same for value nodes. In many cases you might not need this
  in which case you can just put a unit (`()`) type or a type variable as a placeholder.
  
  These are the supported node types:
  
    - **Literal**
        - Represents a literal value like 13, True or "foo".
        - See the documentation in the [Literal](Morphir-IR-Literal) module for details on the supported literal types.
        - See [Wikipedia: Literal](https://en.wikipedia.org/wiki/Literal_(computer_programming)) for more details on
          literals.
    - **Constructor**
        - Reference to a custom type constructor name.
        - If the type constructor has arguments this node will be wrapped into some `Apply` nodes depending on the number
          of arguments.
    - **Tuple**
        - Represents a tuple value.
        - Each element of the tuple is in turn a `Value`.
    - **List**
        - Represents a list of values.
        - Each item of the list is in turn a `Value`.
    - **Record**
        - Represents a record value.
        - Each field value of the record is in turn a `Value`.
    - **Variable**
        - Reference to a variable.
    - **Reference**
        - Reference to another value within or outside the module.
        - References are always full-qualified to make resolution easier.
    - **Field**
        - Represents accessing a field on a record together with the target expression.
        - This is done using the dot notation in Elm: `foo.bar`
    - **FieldFunction**
        - Represents accessing a field on a record without the target expression.
        - This is a shortcut to refer to the function that extracts the field from the input.
        - This is done using the dot notation in Elm without a target expression: `.bar`
    - **Apply**
        - Represents a function application.
        - The two arguments are the target function and the argument.
        - Multi-argument invocations are expressed by wrapping multiple `Apply` nodes in each other (currying).
    - **Lambda**
        - Represents a lambda abstraction.
        - The first argument is a pattern to match on the input, the second is the lambda expression's body.
    - **LetDefinition**
        - Represents a single let binding.
        - Multiple let bindings are achieved through wrapping multiple let expressions into each other.
    - **LetRecursion**
        - Special let binding that allows mutual recursion between the bindings.
        - This is necessary because `LetDefinition` will not make recursion possible due to its scoping rules.
    - **Destructure**
        - Applies a pattern match to the first expression and passes any extracted variables to the second expression.
        - This can be represented as a let expression with a pattern binding or a single-case pattern-match in Elm.
    - **IfThenElse**
        - Represents a simple if/then/else expression.
        - The 3 arguments are: the condition, the then branch and the else branch.
    - **PatternMatch**
        - Represents a pattern-match.
    - **UpdateRecord**
        - Expression to update one or more fields of a record.
        - As usual in FP this is a copy-on-update so no mutation is happening.
    - **Unit**
        - Represents the single value in the Unit type.
        - When you find Unit in the IR it usually means: "There's nothing useful here".
  
  */
  export type Value<ta, va> = Apply<ta, va> | Constructor<ta, va> | Destructure<ta, va> | Field<ta, va> | FieldFunction<ta, va> | IfThenElse<ta, va> | Lambda<ta, va> | LetDefinition<ta, va> | LetRecursion<ta, va> | List<ta, va> | Literal<ta, va> | PatternMatch<ta, va> | Record<ta, va> | Reference<ta, va> | Tuple<ta, va> | Unit<ta, va> | UpdateRecord<ta, va> | Variable<ta, va>
  
  export function decodeValue(varDecoders, input) {
  let decoderMap = new Map();
  decoderMap.set("Apply", decodeApply.bind(varDecoders));
  decoderMap.set("Constructor", decodeConstructor.bind(varDecoders));
  decoderMap.set("Destructure", decodeDestructure.bind(varDecoders));
  decoderMap.set("Field", decodeField.bind(varDecoders));
  decoderMap.set("FieldFunction", decodeFieldFunction.bind(varDecoders));
  decoderMap.set("IfThenElse", decodeIfThenElse.bind(varDecoders));
  decoderMap.set("Lambda", decodeLambda.bind(varDecoders));
  decoderMap.set("LetDefinition", decodeLetDefinition.bind(varDecoders));
  decoderMap.set("LetRecursion", decodeLetRecursion.bind(varDecoders));
  decoderMap.set("List", decodeList.bind(varDecoders));
  decoderMap.set("Literal", decodeLiteral.bind(varDecoders));
  decoderMap.set("PatternMatch", decodePatternMatch.bind(varDecoders));
  decoderMap.set("Record", decodeRecord.bind(varDecoders));
  decoderMap.set("Reference", decodeReference.bind(varDecoders));
  decoderMap.set("Tuple", decodeTuple.bind(varDecoders));
  decoderMap.set("Unit", decodeUnit.bind(varDecoders));
  decoderMap.set("UpdateRecord", decodeUpdateRecord.bind(varDecoders));
  decoderMap.set("Variable", decodeVariable.bind(varDecoders));
  codecs.decodeCustomType(decoderMap, input);
  }
  
  
  
  export interface Apply<ta, va> {
    kind: "Apply";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
  }
  
  export function decodeApply(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Apply", ["Arg1", "Arg2", "Arg3"], [varDecoders.Va.bind(null), Morphir_IR_Value.decodeValue.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)], input);
  }
  
  export interface Constructor<ta, va> {
    kind: "Constructor";
    arg1: va;
    arg2: Morphir_IR_FQName.FQName;
  }
  
  export function decodeConstructor(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Constructor", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), Morphir_IR_FQName.decodeFQName.bind(null, varDecoders)], input);
  }
  
  export interface Destructure<ta, va> {
    kind: "Destructure";
    arg1: va;
    arg2: Morphir_IR_Value.Pattern<va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
    arg4: Morphir_IR_Value.Value<ta, va>;
  }
  
  export function decodeDestructure(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Destructure", ["Arg1", "Arg2", "Arg3", "Arg4"], [varDecoders.Va.bind(null), Morphir_IR_Value.decodePattern.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)], input);
  }
  
  export interface Field<ta, va> {
    kind: "Field";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Morphir_IR_Name.Name;
  }
  
  export function decodeField(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Field", ["Arg1", "Arg2", "Arg3"], [varDecoders.Va.bind(null), Morphir_IR_Value.decodeValue.bind(null, varDecoders), Morphir_IR_Name.decodeName.bind(null, varDecoders)], input);
  }
  
  export interface FieldFunction<ta, va> {
    kind: "FieldFunction";
    arg1: va;
    arg2: Morphir_IR_Name.Name;
  }
  
  export function decodeFieldFunction(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("FieldFunction", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), Morphir_IR_Name.decodeName.bind(null, varDecoders)], input);
  }
  
  export interface IfThenElse<ta, va> {
    kind: "IfThenElse";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
    arg4: Morphir_IR_Value.Value<ta, va>;
  }
  
  export function decodeIfThenElse(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("IfThenElse", ["Arg1", "Arg2", "Arg3", "Arg4"], [varDecoders.Va.bind(null), Morphir_IR_Value.decodeValue.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)], input);
  }
  
  export interface Lambda<ta, va> {
    kind: "Lambda";
    arg1: va;
    arg2: Morphir_IR_Value.Pattern<va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
  }
  
  export function decodeLambda(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Lambda", ["Arg1", "Arg2", "Arg3"], [varDecoders.Va.bind(null), Morphir_IR_Value.decodePattern.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)], input);
  }
  
  export interface LetDefinition<ta, va> {
    kind: "LetDefinition";
    arg1: va;
    arg2: Morphir_IR_Name.Name;
    arg3: Morphir_IR_Value.Definition<ta, va>;
    arg4: Morphir_IR_Value.Value<ta, va>;
  }
  
  export function decodeLetDefinition(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("LetDefinition", ["Arg1", "Arg2", "Arg3", "Arg4"], [varDecoders.Va.bind(null), Morphir_IR_Name.decodeName.bind(null, varDecoders), Morphir_IR_Value.decodeDefinition.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)], input);
  }
  
  export interface LetRecursion<ta, va> {
    kind: "LetRecursion";
    arg1: va;
    arg2: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Definition<ta, va>]>;
    arg3: Morphir_IR_Value.Value<ta, va>;
  }
  
  export function decodeLetRecursion(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("LetRecursion", ["Arg1", "Arg2", "Arg3"], [varDecoders.Va.bind(null), codecs.decodeDict.bind(null, Morphir_IR_Name.decodeName.bind(null, varDecoders), Morphir_IR_Value.decodeDefinition.bind(null, varDecoders)), Morphir_IR_Value.decodeValue.bind(null, varDecoders)], input);
  }
  
  export interface List<ta, va> {
    kind: "List";
    arg1: va;
    arg2: Array<Morphir_IR_Value.Value<ta, va>>;
  }
  
  export function decodeList(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("List", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), codecs.decodeList.bind(null, Morphir_IR_Value.decodeValue.bind(null, varDecoders))], input);
  }
  
  export interface Literal<ta, va> {
    kind: "Literal";
    arg1: va;
    arg2: Morphir_IR_Literal.Literal;
  }
  
  export function decodeLiteral(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Literal", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), Morphir_IR_Literal.decodeLiteral.bind(null, varDecoders)], input);
  }
  
  export interface PatternMatch<ta, va> {
    kind: "PatternMatch";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Array<[Morphir_IR_Value.Pattern<va>, Morphir_IR_Value.Value<ta, va>]>;
  }
  
  export function decodePatternMatch(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("PatternMatch", ["Arg1", "Arg2", "Arg3"], [varDecoders.Va.bind(null), Morphir_IR_Value.decodeValue.bind(null, varDecoders), codecs.decodeList.bind(null, codecs.decodeTuple.bind(null, [Morphir_IR_Value.decodePattern.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)]))], input);
  }
  
  export interface Record<ta, va> {
    kind: "Record";
    arg1: va;
    arg2: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Value<ta, va>]>;
  }
  
  export function decodeRecord(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Record", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), codecs.decodeList.bind(null, codecs.decodeTuple.bind(null, [Morphir_IR_Name.decodeName.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)]))], input);
  }
  
  export interface Reference<ta, va> {
    kind: "Reference";
    arg1: va;
    arg2: Morphir_IR_FQName.FQName;
  }
  
  export function decodeReference(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Reference", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), Morphir_IR_FQName.decodeFQName.bind(null, varDecoders)], input);
  }
  
  export interface Tuple<ta, va> {
    kind: "Tuple";
    arg1: va;
    arg2: Array<Morphir_IR_Value.Value<ta, va>>;
  }
  
  export function decodeTuple(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Tuple", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), codecs.decodeList.bind(null, Morphir_IR_Value.decodeValue.bind(null, varDecoders))], input);
  }
  
  export interface Unit<ta, va> {
    kind: "Unit";
    arg1: va;
  }
  
  export function decodeUnit(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Unit", ["Arg1"], [varDecoders.Va.bind(null)], input);
  }
  
  export interface UpdateRecord<ta, va> {
    kind: "UpdateRecord";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Value<ta, va>]>;
  }
  
  export function decodeUpdateRecord(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("UpdateRecord", ["Arg1", "Arg2", "Arg3"], [varDecoders.Va.bind(null), Morphir_IR_Value.decodeValue.bind(null, varDecoders), codecs.decodeList.bind(null, codecs.decodeTuple.bind(null, [Morphir_IR_Name.decodeName.bind(null, varDecoders), Morphir_IR_Value.decodeValue.bind(null, varDecoders)]))], input);
  }
  
  export interface Variable<ta, va> {
    kind: "Variable";
    arg1: va;
    arg2: Morphir_IR_Name.Name;
  }
  
  export function decodeVariable(varDecoders, input) {
  return codecs.decodeCustomTypeVariant("Variable", ["Arg1", "Arg2"], [varDecoders.Va.bind(null), Morphir_IR_Name.decodeName.bind(null, varDecoders)], input);
  }
  
}

