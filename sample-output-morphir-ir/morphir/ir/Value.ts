// Generated by morphir-elm

import { Morphir_IR_FQName } from "./../../morphir/ir/FQName"
import { Morphir_IR_Literal } from "./../../morphir/ir/Literal"
import { Morphir_IR_Name } from "./../../morphir/ir/Name"
import { Morphir_IR_Type } from "./../../morphir/ir/Type"

export namespace Morphir_IR_Value {
  /* Type that represents a value or function definition. A definition is the actual data or logic as opposed to a specification
  which is just the specification of those. Value definitions can be typed or untyped. Exposed values have to be typed.
  */
  export type Definition<ta, va> = {
    InputTypes: Array<[Morphir_IR_Name.Name, va, Morphir_IR_Type.Type<ta>]>;
    OutputType: Morphir_IR_Type.Type<ta>;
    Body: Morphir_IR_Value.Value<ta, va>;
  }
  
  /* Type that represents a pattern. A pattern can do two things: match on a specific shape or exact value and extract
  parts of a value into variables. It's a recursive data structure made of of the following building blocks:
  
    - **WildcardPattern**
        - Matches any value and does not extract any variables.
        - `_` in Elm
    - **AsPattern**
        - Assigns a variable name to the value matched by a nested pattern.
        - `(...) as foo` in Elm
        - Special case: when there is just a variable name in a pattern in Elm it will be represented as a
          `WildcardPattern` wrapped in an `AsPattern`
    - **TuplePattern**
        - Matches on a tuple where each element matches the nested patterns.
    - **ConstructorPattern**
        - Matches on a type constructor and its arguments.
    - **EmptyListPattern**
        - Matches on an empty list.
    - **HeadTailPattern**
        - Matches on the head and the tail of a list.
        - Combined with `EmptyListPattern` it can match on lists of any specific sizes.
    - **LiteralPattern**
        - Matches an an exact literal value.
    - **UnitPattern**
        - Matches the `Unit` value only.
  
  */
  export type Pattern<a> = AsPattern<a> | ConstructorPattern<a> | EmptyListPattern<a> | HeadTailPattern<a> | LiteralPattern<a> | TuplePattern<a> | UnitPattern<a> | WildcardPattern<a>
  
  export interface AsPattern<a> {
    kind: "AsPattern";
    arg1: a;
    arg2: Morphir_IR_Value.Pattern<a>;
    arg3: Morphir_IR_Name.Name;
  }
  
  export interface ConstructorPattern<a> {
    kind: "ConstructorPattern";
    arg1: a;
    arg2: Morphir_IR_FQName.FQName;
    arg3: Array<Morphir_IR_Value.Pattern<a>>;
  }
  
  export interface EmptyListPattern<a> {
    kind: "EmptyListPattern";
    arg1: a;
  }
  
  export interface HeadTailPattern<a> {
    kind: "HeadTailPattern";
    arg1: a;
    arg2: Morphir_IR_Value.Pattern<a>;
    arg3: Morphir_IR_Value.Pattern<a>;
  }
  
  export interface LiteralPattern<a> {
    kind: "LiteralPattern";
    arg1: a;
    arg2: Morphir_IR_Literal.Literal;
  }
  
  export interface TuplePattern<a> {
    kind: "TuplePattern";
    arg1: a;
    arg2: Array<Morphir_IR_Value.Pattern<a>>;
  }
  
  export interface UnitPattern<a> {
    kind: "UnitPattern";
    arg1: a;
  }
  
  export interface WildcardPattern<a> {
    kind: "WildcardPattern";
    arg1: a;
  }
  
  /* A value without any additional information.
  */
  export type RawValue = Morphir_IR_Value.Value<[], []>
  
  /* Type that represents a value or function specification. The specification of what the value or function
  is without the actual data or logic behind it.
  */
  export type Specification<ta> = {
    Inputs: Array<[Morphir_IR_Name.Name, Morphir_IR_Type.Type<ta>]>;
    Output: Morphir_IR_Type.Type<ta>;
  }
  
  /* A value with type information.
  */
  export type TypedValue = Morphir_IR_Value.Value<[], Morphir_IR_Type.Type<[]>>
  
  /* Type that represents a value expression. This is a recursive data structure with various node types representing
  each possible language construct.
  
  The extra type parameters `ta` and `va` allow you to add type and value attributes. Type attributes allow you to add
  extra information to each type node. Value attributes do the same for value nodes. In many cases you might not need this
  in which case you can just put a unit (`()`) type or a type variable as a placeholder.
  
  These are the supported node types:
  
    - **Literal**
        - Represents a literal value like 13, True or "foo".
        - See the documentation in the [Literal](Morphir-IR-Literal) module for details on the supported literal types.
        - See [Wikipedia: Literal](https://en.wikipedia.org/wiki/Literal_(computer_programming)) for more details on
          literals.
    - **Constructor**
        - Reference to a custom type constructor name.
        - If the type constructor has arguments this node will be wrapped into some `Apply` nodes depending on the number
          of arguments.
    - **Tuple**
        - Represents a tuple value.
        - Each element of the tuple is in turn a `Value`.
    - **List**
        - Represents a list of values.
        - Each item of the list is in turn a `Value`.
    - **Record**
        - Represents a record value.
        - Each field value of the record is in turn a `Value`.
    - **Variable**
        - Reference to a variable.
    - **Reference**
        - Reference to another value within or outside the module.
        - References are always full-qualified to make resolution easier.
    - **Field**
        - Represents accessing a field on a record together with the target expression.
        - This is done using the dot notation in Elm: `foo.bar`
    - **FieldFunction**
        - Represents accessing a field on a record without the target expression.
        - This is a shortcut to refer to the function that extracts the field from the input.
        - This is done using the dot notation in Elm without a target expression: `.bar`
    - **Apply**
        - Represents a function application.
        - The two arguments are the target function and the argument.
        - Multi-argument invocations are expressed by wrapping multiple `Apply` nodes in each other (currying).
    - **Lambda**
        - Represents a lambda abstraction.
        - The first argument is a pattern to match on the input, the second is the lambda expression's body.
    - **LetDefinition**
        - Represents a single let binding.
        - Multiple let bindings are achieved through wrapping multiple let expressions into each other.
    - **LetRecursion**
        - Special let binding that allows mutual recursion between the bindings.
        - This is necessary because `LetDefinition` will not make recursion possible due to its scoping rules.
    - **Destructure**
        - Applies a pattern match to the first expression and passes any extracted variables to the second expression.
        - This can be represented as a let expression with a pattern binding or a single-case pattern-match in Elm.
    - **IfThenElse**
        - Represents a simple if/then/else expression.
        - The 3 arguments are: the condition, the then branch and the else branch.
    - **PatternMatch**
        - Represents a pattern-match.
    - **UpdateRecord**
        - Expression to update one or more fields of a record.
        - As usual in FP this is a copy-on-update so no mutation is happening.
    - **Unit**
        - Represents the single value in the Unit type.
        - When you find Unit in the IR it usually means: "There's nothing useful here".
  
  */
  export type Value<ta, va> = Apply<ta, va> | Constructor<ta, va> | Destructure<ta, va> | Field<ta, va> | FieldFunction<ta, va> | IfThenElse<ta, va> | Lambda<ta, va> | LetDefinition<ta, va> | LetRecursion<ta, va> | List<ta, va> | Literal<ta, va> | PatternMatch<ta, va> | Record<ta, va> | Reference<ta, va> | Tuple<ta, va> | Unit<ta, va> | UpdateRecord<ta, va> | Variable<ta, va>
  
  export interface Apply<ta, va> {
    kind: "Apply";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
  }
  
  export interface Constructor<ta, va> {
    kind: "Constructor";
    arg1: va;
    arg2: Morphir_IR_FQName.FQName;
  }
  
  export interface Destructure<ta, va> {
    kind: "Destructure";
    arg1: va;
    arg2: Morphir_IR_Value.Pattern<va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
    arg4: Morphir_IR_Value.Value<ta, va>;
  }
  
  export interface Field<ta, va> {
    kind: "Field";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Morphir_IR_Name.Name;
  }
  
  export interface FieldFunction<ta, va> {
    kind: "FieldFunction";
    arg1: va;
    arg2: Morphir_IR_Name.Name;
  }
  
  export interface IfThenElse<ta, va> {
    kind: "IfThenElse";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
    arg4: Morphir_IR_Value.Value<ta, va>;
  }
  
  export interface Lambda<ta, va> {
    kind: "Lambda";
    arg1: va;
    arg2: Morphir_IR_Value.Pattern<va>;
    arg3: Morphir_IR_Value.Value<ta, va>;
  }
  
  export interface LetDefinition<ta, va> {
    kind: "LetDefinition";
    arg1: va;
    arg2: Morphir_IR_Name.Name;
    arg3: Morphir_IR_Value.Definition<ta, va>;
    arg4: Morphir_IR_Value.Value<ta, va>;
  }
  
  export interface LetRecursion<ta, va> {
    kind: "LetRecursion";
    arg1: va;
    arg2: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Definition<ta, va>]>;
    arg3: Morphir_IR_Value.Value<ta, va>;
  }
  
  export interface List<ta, va> {
    kind: "List";
    arg1: va;
    arg2: Array<Morphir_IR_Value.Value<ta, va>>;
  }
  
  export interface Literal<ta, va> {
    kind: "Literal";
    arg1: va;
    arg2: Morphir_IR_Literal.Literal;
  }
  
  export interface PatternMatch<ta, va> {
    kind: "PatternMatch";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Array<[Morphir_IR_Value.Pattern<va>, Morphir_IR_Value.Value<ta, va>]>;
  }
  
  export interface Record<ta, va> {
    kind: "Record";
    arg1: va;
    arg2: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Value<ta, va>]>;
  }
  
  export interface Reference<ta, va> {
    kind: "Reference";
    arg1: va;
    arg2: Morphir_IR_FQName.FQName;
  }
  
  export interface Tuple<ta, va> {
    kind: "Tuple";
    arg1: va;
    arg2: Array<Morphir_IR_Value.Value<ta, va>>;
  }
  
  export interface Unit<ta, va> {
    kind: "Unit";
    arg1: va;
  }
  
  export interface UpdateRecord<ta, va> {
    kind: "UpdateRecord";
    arg1: va;
    arg2: Morphir_IR_Value.Value<ta, va>;
    arg3: Array<[Morphir_IR_Name.Name, Morphir_IR_Value.Value<ta, va>]>;
  }
  
  export interface Variable<ta, va> {
    kind: "Variable";
    arg1: va;
    arg2: Morphir_IR_Name.Name;
  }
  
}

