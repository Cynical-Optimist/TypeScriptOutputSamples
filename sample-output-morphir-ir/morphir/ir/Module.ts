// Generated by morphir-elm

import * as codecs from "./../../morphir/internal/Codecs";
import { Morphir_IR_AccessControlled } from "./../../morphir/ir/AccessControlled";
import { Morphir_IR_Documented } from "./../../morphir/ir/Documented";
import { Morphir_IR_Name } from "./../../morphir/ir/Name";
import { Morphir_IR_Path } from "./../../morphir/ir/Path";
import { Morphir_IR_Type } from "./../../morphir/ir/Type";
import { Morphir_IR_Value } from "./../../morphir/ir/Value";

export namespace Morphir_IR_Module {
  /* Type that represents a module definition. A module definition contains all the details
  including implementation and private types and values.
  
  A module contains types and values which is represented by two field in this type:
  
    - types: a dictionary of local name to access controlled, documented type specification.
    - values: a dictionary of local name to access controlled value specification.
  
  */
  export type Definition<Ta, Va> = {
    types: Map<
      Morphir_IR_Name.Name,
      Morphir_IR_AccessControlled.AccessControlled<
        Morphir_IR_Documented.Documented<Morphir_IR_Type.Definition<Ta>>
      >
    >;
    values: Map<
      Morphir_IR_Name.Name,
      Morphir_IR_AccessControlled.AccessControlled<
        Morphir_IR_Value.Definition<Ta, Va>
      >
    >;
  };

  export function decodeDefinition<Ta, Va>(
    decodeTa: (input: any) => Ta,
    decodeVa: (input: any) => Va,
    input: any
  ): Definition<Ta, Va> {
    return codecs.decodeRecord(
      codecs.buildCodecMap([
        [
          "types",
          codecs.decodeDict.bind(
            null,
            Morphir_IR_Name.decodeName,
            Morphir_IR_AccessControlled.decodeAccessControlled.bind(
              null,
              Morphir_IR_Documented.decodeDocumented.bind(
                null,
                Morphir_IR_Type.decodeDefinition.bind(null, decodeTa)
              )
            )
          ),
        ],
        [
          "values",
          codecs.decodeDict.bind(
            null,
            Morphir_IR_Name.decodeName,
            Morphir_IR_AccessControlled.decodeAccessControlled.bind(
              null,
              Morphir_IR_Value.decodeDefinition.bind(null, decodeTa, decodeVa)
            )
          ),
        ],
      ]),
      input
    );
  }

  export function encodeDefinition<Ta, Va>(
    encodeTa: (value: Ta) => any,
    encodeVa: (value: Va) => any,
    value: Definition<Ta, Va>
  ): any {
    return codecs.encodeRecord(
      codecs.buildCodecMap([
        [
          "types",
          codecs.encodeDict.bind(
            null,
            Morphir_IR_Name.encodeName,
            Morphir_IR_AccessControlled.encodeAccessControlled.bind(
              null,
              Morphir_IR_Documented.encodeDocumented.bind(
                null,
                Morphir_IR_Type.encodeDefinition.bind(null, encodeTa)
              )
            )
          ),
        ],
        [
          "values",
          codecs.encodeDict.bind(
            null,
            Morphir_IR_Name.encodeName,
            Morphir_IR_AccessControlled.encodeAccessControlled.bind(
              null,
              Morphir_IR_Value.encodeDefinition.bind(null, encodeTa, encodeVa)
            )
          ),
        ],
      ]),
      value
    );
  }

  /* A module name is a unique identifier for a module within a package. It is represented by a path, which is a list of
  names.
  */
  export type ModuleName = Morphir_IR_Path.Path;

  export function decodeModuleName(input: any): ModuleName {
    return Morphir_IR_Path.decodePath(input);
  }

  export function encodeModuleName(value: ModuleName): any {
    return Morphir_IR_Path.encodePath(value);
  }

  /* Type that represents a module specification. A module specification only contains types that are exposed
  publicly and type signatures for values that are exposed publicly.
  
  A module contains types and values which is represented by two field in this type:
  
    - types: a dictionary of local name to documented type specification.
    - values: a dictionary of local name to value specification.
  
  */
  export type Specification<Ta> = {
    types: Map<
      Morphir_IR_Name.Name,
      Morphir_IR_Documented.Documented<Morphir_IR_Type.Specification<Ta>>
    >;
    values: Map<Morphir_IR_Name.Name, Morphir_IR_Value.Specification<Ta>>;
  };

  export function decodeSpecification<Ta>(
    decodeTa: (input: any) => Ta,
    input: any
  ): Specification<Ta> {
    return codecs.decodeRecord(
      codecs.buildCodecMap([
        [
          "types",
          codecs.decodeDict.bind(
            null,
            Morphir_IR_Name.decodeName,
            Morphir_IR_Documented.decodeDocumented.bind(
              null,
              Morphir_IR_Type.decodeSpecification.bind(null, decodeTa)
            )
          ),
        ],
        [
          "values",
          codecs.decodeDict.bind(
            null,
            Morphir_IR_Name.decodeName,
            Morphir_IR_Value.decodeSpecification.bind(null, decodeTa)
          ),
        ],
      ]),
      input
    );
  }

  export function encodeSpecification<Ta>(
    encodeTa: (value: Ta) => any,
    value: Specification<Ta>
  ): any {
    return codecs.encodeRecord(
      codecs.buildCodecMap([
        [
          "types",
          codecs.encodeDict.bind(
            null,
            Morphir_IR_Name.encodeName,
            Morphir_IR_Documented.encodeDocumented.bind(
              null,
              Morphir_IR_Type.encodeSpecification.bind(null, encodeTa)
            )
          ),
        ],
        [
          "values",
          codecs.encodeDict.bind(
            null,
            Morphir_IR_Name.encodeName,
            Morphir_IR_Value.encodeSpecification.bind(null, encodeTa)
          ),
        ],
      ]),
      value
    );
  }
}
