// Generated by morphir-elm

import * as MDF from "../../MorphirStandardDecoderFunctions"

export namespace Codethink_PrizeDraws_AutoGen {
  export class Car {
    kind: "Car";
    arg1: number;
    arg2: string;
    arg3: string;


    constructor(kind: "Car", arg1: number, arg2: string, arg3: string) {
      this.kind = kind;
      this.arg1 = arg1;
      this.arg2 = arg2;
      this.arg3 = arg3;
    }

    toJSON(): ["Car", number, string, string] {
      return [this.kind, this.arg1, this.arg2, this.arg3]
    }

    static fromJSON(input: any): Car {
      return new Car(
        MDF.decodeLiteralString("Car", input[0]),
        MDF.decodeInt(input[1]),
        MDF.decodeString(input[2]),
        MDF.decodeString(input[3]),
      )
    }
  }

  export type Cash = number


  export type GemStone = Diamond | Emerald | Opal | Ruby | Saphire | Topaz

  export class Diamond {
    kind: "Diamond"

    Constructor() {
      this.kind = "Diamond"
    }

    toJSON(): "Diamond" { return "Diamond" }

    static fromJSON(input: any): Diamond {
      let _: "Diamond" = MDF.decodeLiteralString("Diamond", input)
      return new Diamond()
    }
  }

  export class Emerald {
    kind: "Emerald"

    Constructor() {
      this.kind = "Emerald"
    }

    toJSON(): "Emerald" { return "Emerald" }

    static fromJSON(input: any): Emerald {
      let _: "Emerald" = MDF.decodeLiteralString("Emerald", input)
      return new Emerald()
    }
  }

  export class Opal {
    kind: "Opal"

    Constructor() {
      this.kind = "Opal"
    }

    toJSON(): "Opal" { return "Opal" }

    static fromJSON(input: any): Opal {
      let _: "Opal" = MDF.decodeLiteralString("Opal", input)
      return new Opal()
    }
  }

  export class Ruby {
    kind: "Ruby"

    Constructor() {
      this.kind = "Ruby"
    }

    toJSON(): "Ruby" { return "Ruby" }

    static fromJSON(input: any): Ruby {
      let _: "Ruby" = MDF.decodeLiteralString("Ruby", input)
      return new Ruby()
    }
  }

  export class Saphire {
    kind: "Saphire"

    Constructor() {
      this.kind = "Saphire"
    }

    toJSON(): "Saphire" { return "Saphire" }

    static fromJSON(input: any): Saphire {
      let _: "Saphire" = MDF.decodeLiteralString("Saphire", input)
      return new Saphire()
    }
  }

  export class Topaz {
    kind: "Topaz"

    Constructor() {
      this.kind = "Topaz"
    }

    toJSON(): "Topaz" { return "Topaz" }

    static fromJSON(input: any): Topaz {
      let _: "Topaz" = MDF.decodeLiteralString("Topaz", input)
      return new Topaz()
    }
  }


  export class Holiday {
    location: string;
    duration: number;
    allExpenses: boolean;

    constructor(location: string, duration: number, allExpenses: boolean) {
      this.location = location;
      this.duration = duration;
      this.allExpenses = allExpenses;
    }

    // No "toJSON" function is needed. The output would be the same as the input

    static fromJSON(input: any): Holiday {
      return new Holiday(
        MDF.decodeString(input.location),
        MDF.decodeInt(input.duration),
        MDF.decodeBoolean(input.allExpenses)
      )
    }
  }


  export type Prize<mainPrizeType, awardType> = Award<awardType> | MainPrize<mainPrizeType>

  export class Award<awardType> {
    kind: "Award";
    arg1: string;
    arg2: awardType;

    constructor(kind: "Award", arg1: string, arg2: awardType) {
      this.kind = kind;
      this.arg1 = arg1;
      this.arg2 = arg2;
    }

    toJSON(): ["Award", string, awardType] {
      return ["Award", this.arg1, this.arg2]
    }

    static fromJSON<awardType>(input: any, classList: [awardType]): Award<awardType> {
      return new Award<awardType>(
        MDF.decodeLiteralString("Award", input[0]),
        MDF.decodeString(input[1]),
        MDF.classFromJSON(classList[0], input[2])
      )
    }
  }

  export class MainPrize<mainPrizeType> {
    kind: "MainPrize";
    arg1: mainPrizeType;

    constructor(kind: "MainPrize", arg1: mainPrizeType) {
      this.kind = kind;
      this.arg1 = arg1;
    }

    toJSON(): ["MainPrize", mainPrizeType] {
      return ["MainPrize", this.arg1]
    }

    static fromJSON<mainPrizeType>(input: any, classList: [mainPrizeType]): MainPrize<mainPrizeType> {
      return new MainPrize<mainPrizeType>(
        MDF.decodeLiteralString("MainPrize", input[0]),
        MDF.classFromJSON(classList[0], input[1])
      )
    }
  }

}

