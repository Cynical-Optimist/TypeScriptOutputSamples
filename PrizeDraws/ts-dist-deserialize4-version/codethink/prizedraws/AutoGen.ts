// Generated by morphir-elm

import * as MDF from "../../MorphirStandardDecoderFunctions"

export namespace Codethink_PrizeDraws_AutoGen {
  export interface Car {
    kind: "Car";
    arg1: number;
    arg2: string;
    arg3: string;
  }

  export function decodeCar(input: any): Car {
    let parsedArguments = MDF.decodeTuple(
      [
        MDF.decodeLiteralString.bind(null, "Car"),
        MDF.decodeInt,
        MDF.decodeString,
        MDF.decodeString,
      ],
      input
    )
    return {
      kind: parsedArguments[0],
      arg1: parsedArguments[1],
      arg2: parsedArguments[2],
      arg3: parsedArguments[3],
    }
  }

  export type Cash = number
  export function decodeCash(input: any): Cash {
    return MDF.decodeInt(input)
  }


  export type GemStone = Diamond | Emerald | Opal | Ruby | Saphire | Topaz

  export function decodeGemstone(input: any): GemStone {
    // Note that when 'kind' is the only field, the varaint will be encoded as a string,
    // not as a tuple containing a string.
    if (input == "Diamond") return { kind: input };
    if (input == "Emerald") return { kind: input };
    if (input == "Opal") return { kind: input };
    if (input == "Ruby") return { kind: input };
    if (input == "Saphire") return { kind: input };
    if (input == "Topaz") return { kind: input };
    //Only reaches this section if none of the valid options were matched
    //throw new MDF.DecodeError(`Expected Gemstone, got ${typeof (input)}`);
  }

  export interface Diamond {
    kind: "Diamond";
  }

  export function decodeDiamond(input: any): Diamond {
    let kindString = MDF.decodeLiteralString.bind("Diamond")
    return { kind: kindString }
  }

  export interface Emerald {
    kind: "Emerald";
  }

  export function decodeEmerald(input: any): Emerald {
    let kindString = MDF.decodeLiteralString.bind("Emerald")
    return { kind: kindString }
  }

  export interface Opal {
    kind: "Opal";
  }

  export function decodeOpal(input: any): Opal {
    let kindString = MDF.decodeLiteralString.bind("Opal")
    return { kind: kindString }
  }

  export interface Ruby {
    kind: "Ruby";
  }

  export function decodeRuby(input: any): Ruby {
    let kindString = MDF.decodeLiteralString.bind("Ruby")
    return { kind: kindString }
  }

  export interface Saphire {
    kind: "Saphire";
  }

  export function decodeSaphire(input: any): Saphire {
    let kindString = MDF.decodeLiteralString.bind("Saphire")
    return { kind: kindString }
  }

  export interface Topaz {
    kind: "Topaz";
  }

  export function decodeTopaz(input: any): Topaz {
    let kindString = MDF.decodeLiteralString.bind("Topaz")
    return { kind: kindString }
  }


  export type Holiday = {
    location: string;
    duration: number;
    allExpenses: boolean;
  }

  export function decodeHoliday(input: any): Holiday {
    let fieldDecoders: MDF.DecoderMap = new Map(
      Object.entries(
        {
          location: MDF.decodeString,
          duration: MDF.decodeInt,
          allExpenses: MDF.decodeBoolean,
        }
      )
    )
    let returnedHoliday: Holiday = MDF.decodeRecord(fieldDecoders, input)
    return returnedHoliday
  }


  export type Prize<mainPrizeType, awardType> = Award<awardType> | MainPrize<mainPrizeType>

  export function decodePrize<mainPrizeType, awardType>(
    decoderList: MDF.DecoderList, input: any
  ): Prize<mainPrizeType, awardType> {
    // Assumes that decoderList has at least two elements,
    // that the first element is a decoder function for mainPrizeType
    // and the second element is a decoder function for awardType

    // Note that when a constructor has multiple fields
    // the constructor will be encoded as a tuple, with the kind name as element 0
    // if (!(input instanceof Array)) {
    //   throw new MDF.DecodeError(`Expected Prize constructor, got ${typeof (input)}`);
    // }
    if (input[0] == "MainPrize") return decodeMainPrize<mainPrizeType>([decoderList[0]], input);
    if (input[0] == "Award") return decodeAward<awardType>([decoderList[1]], input);

    // Only reaches this section if none of the valid options were matched
    // throw new MDF.DecodeError(`Expected Gemstone, got ${typeof (input)}`);
  }

  export interface Award<awardType> {
    // Note that the autogenerated code would actually show `Award<mainPrizeType, awardType>`
    // I think this can be considered a bug. It should probably output `Award<awardType>`
    kind: "Award";
    arg1: string;
    arg2: awardType;
  }

  export function decodeAward<awardType>(
    decoderList: MDF.DecoderList, input: any
  ): Award<awardType> {
    // Assumes that decoderList has at least one element,
    // and the first element is a decoder that decodes awardType
    let parsedArguments = MDF.decodeTuple(
      [
        MDF.decodeLiteralString.bind(null, "Award"),
        MDF.decodeString,
        decoderList[0],
      ],
      input
    )
    return {
      kind: parsedArguments[0],
      arg1: parsedArguments[1],
      arg2: parsedArguments[2],
    }
  }

  export interface MainPrize<mainPrizeType> {
    kind: "MainPrize";
    arg1: mainPrizeType;
  }

  export function decodeMainPrize<mainPrizeType>(
    decoderList: MDF.DecoderList, input: any
  ): MainPrize<mainPrizeType> {
    // Assumes that decoderList has at least one element,
    // and the first element is a decoder that decodes mainPrizeType
    let parsedArguments = MDF.decodeTuple(
      [
        MDF.decodeLiteralString.bind(null, "MainPrize"),
        decoderList[0],
      ],
      input
    )
    return {
      kind: parsedArguments[0],
      arg1: parsedArguments[1],
    }
  }

}

